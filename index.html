<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Generador Ficha Complementaria (2026) – SENA Tolima</title>
  <style>
    :root{
      /* Paleta base (alineada a tus proyectos anteriores) */
      --green-base:#39a900;
            --green:var(--green-base);
--green-dark:#1b5000;
      --green-soft:#4fb100;
      --bg:#f2f4f7;
      --card:#ffffff;
      --text:#0f172a;
      --muted:#64748b;
      --border:#e5e7eb;
      --border-strong:#cbd5e1;
      --shadow:0 10px 30px rgba(2,6,23,.08);
      --shadow-soft:0 2px 10px rgba(15,23,42,.06);
      --danger:#b91c1c;
      --warn:#b45309;
      --ok:#14532d;
      --radius:16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
      background:var(--bg);
      color:var(--text);
    }
    header{
      background:#fff;
      border-bottom:1px solid var(--border);
      border-top:none;
      box-shadow:none;
      position:sticky; top:0; z-index:10;
    }
    header::before, header::after{content:none !important; display:none !important;}
    .header-inner{
      max-width:1200px; margin:0 auto;
      display:flex; align-items:center; gap:14px;
      padding:12px 16px;
    }
    .logo{
      width:44px; height:44px; border-radius:12px;
      background:#fff;
      border:1px solid var(--border);
      box-shadow:0 6px 14px rgba(2,6,23,.08);
      display:flex; align-items:center; justify-content:center;
      overflow:hidden;
      flex:0 0 auto;
    }
    .logo img{
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
    }
    .titleblock{line-height:1.15}
    .titleblock .t1{font-size:13px; font-weight:700; color:var(--green-dark)}
    .titleblock .t2{font-size:16px; font-weight:800}
    .titleblock .t3{font-size:12px; color:var(--muted); margin-top:2px}

    main{max-width:1200px; margin:16px auto; padding:0 16px 48px}
    .grid{display:grid; grid-template-columns: 310px 1fr; gap:16px}
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }

    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow-soft);
    }
    .card-header{
      padding:14px 16px;
      border-bottom:1px solid var(--border);
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .card-header h2{margin:0; font-size:14px; letter-spacing:.3px}
    .card-body{padding:16px}
    .badge{
      font-size:12px; font-weight:700;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(20,83,45,.18);
      background:rgba(57,169,0,.10);
      color:var(--ok);
      white-space:nowrap;
    }
    .badge.warn{
      border:1px solid rgba(124,45,18,.18);
      background:rgba(245,158,11,.14);
      color:#7c2d12;
    }
    .badge.yellow{
      border:1px solid rgba(161,98,7,.18);
      background:rgba(253,224,71,.22);
      color:#854d0e;
    }

    .badge.danger{
      border:1px solid rgba(185,28,28,.18);
      background:rgba(185,28,28,.10);
      color:var(--danger);
    }

    .step-list{display:flex; flex-direction:column; gap:10px}
    .step{
      padding:12px 12px;
      border-radius:14px;
      border:1px solid var(--border);
      background:#fff;
      cursor:pointer;
      display:flex; gap:10px; align-items:flex-start;
      transition:transform .08s ease, border-color .12s ease, box-shadow .12s ease;
    }
    .step:hover{transform:translateY(-1px); border-color:#c7f9d0; box-shadow:0 10px 20px rgba(2,6,23,.06)}
    .step.active{border-color:rgba(57,169,0,.55); box-shadow:0 12px 26px rgba(57,169,0,.12)}
    .step .num{
      width:28px; height:28px; border-radius:10px;
      display:flex; align-items:center; justify-content:center;
      background:rgba(57,169,0,.12);
      border:1px solid rgba(20,83,45,.18);
      color:var(--green-dark);
      font-weight:900;
      flex:0 0 auto;
    }
    .step .meta{flex:1}
    .step .meta .name{font-weight:800; font-size:13px}
    .step .meta .sub{font-size:12px; color:var(--muted); margin-top:2px}
    .step .state{
      margin-left:auto;
      font-size:12px; font-weight:800;
      padding:5px 9px; border-radius:999px;
      border:1px solid var(--border);
      color:var(--muted);
      background:#f8fafc;
      flex:0 0 auto;
    }
    .step.saved .state{border-color:rgba(20,83,45,.18); background:rgba(57,169,0,.10); color:var(--ok)}

    .section{margin-bottom:14px}
    .section-title{
      font-size:12px; font-weight:900;
      letter-spacing:.4px;
      color:var(--green-dark);
      text-transform:uppercase;
      margin:0 0 10px 0;
      display:flex; align-items:center; gap:10px;
    }
    .section-title::before{
      content:"";
      width:10px; height:10px; border-radius:3px;
      background:var(--green-base);
      box-shadow:0 0 0 3px rgba(57,169,0,.12);
      flex:0 0 auto;
    }

    .form{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:10px;
    }
    .field{grid-column: span 6;}
    .field.full{grid-column: 1 / -1;}
    .field.col4{grid-column: span 4;}
    .field.col3{grid-column: span 3;}
    .field.col8{grid-column: span 8;}
    .field label{
      display:flex; align-items:center; justify-content:space-between;
      font-size:12px; font-weight:800; margin-bottom:6px;
    }
    .req{color:var(--danger); font-weight:900}
    input[type="text"], input[type="email"], input[type="number"], input[type="date"], input[type="time"], input[type="tel"], textarea, select{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--border-strong);
      background:#fff;
      outline:none;
      font-size:13px;
    }
    textarea{min-height:90px; resize:vertical}
    input[readonly]{
      background:#f8fafc;
      color:#334155;
    }
    .hint{font-size:12px; color:var(--muted); margin-top:6px}

    
    .pdf-month-summary{
      margin-top:10px;
      font-size:16px;
      line-height:1.35;
    }
    .pdf-month-summary .pms-title{
      font-weight:900;
      letter-spacing:.2px;
      margin:0 0 8px 0;
      color:var(--green-dark);
    }
    .pdf-month-summary .pms-page{
      padding:10px 12px;
      border-radius:14px;
      background:var(--green-dark);
      color:#ffffff;
      box-shadow:0 10px 18px rgba(27,80,0,.18);
      margin-top:10px;
    }
    .pdf-month-summary .pms-line{font-weight:900; margin-top:2px;}
    .pdf-month-summary .pms-muted{opacity:.94; font-weight:800; margin-top:4px;}
    .pdf-month-summary .pms-total{
      padding:10px 12px;
      border-radius:14px;
      background:#1d4ed8;
      color:#ffffff;
      box-shadow:0 10px 18px rgba(29,78,216,.18);
      margin-top:10px;
    }
    .pdf-month-summary .pms-total-hours{
      margin-top:6px;
      font-weight:900;
      opacity:.98;
    }
    @media print{
      .pdf-month-summary .pms-page{ break-after: page; page-break-after: always; }
      .pdf-month-summary .pms-total{ break-before: page; page-break-before: always; }
    }
/* Fechas: escritura DD/MM/AAAA + selector nativo */

    /* Días a programar (LU–SA) */
    .dow-select{
      display:grid;
      grid-template-columns:repeat(6, 1fr);
      gap:8px;
      padding:8px;
      border:1px solid var(--border);
      border-radius:12px;
      background:#ffffff;
    }

    /* Horario complementario (jornada mixta) */
    .comp-panel{
      margin-top:10px;
      padding:10px;
      border:1px dashed rgba(15,23,42,.35);
      border-radius:14px;
      background:rgba(241,245,249,.6);
    }
    .comp-panel .hint{ margin-top:6px; }
    .comp-grid{
      display:grid;
      grid-template-columns:repeat(12, 1fr);
      gap:10px;
      margin-top:6px;
    }
    .dow-col{
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:6px;
      padding:8px 6px;
      border-radius:10px;
      background:rgba(148,163,184,.10);
    }
    .dow-name{
      font-weight:900;
      font-size:12px;
      letter-spacing:.06em;
      color:var(--text);
    }
    .dow-col input[type="checkbox"]{
      width:18px;
      height:18px;
      cursor:pointer;
      accent-color: var(--ok);
    }
    @media (max-width:760px){
      .dow-select{ grid-template-columns:repeat(3, 1fr); }
    }


    .date-field{
      display:flex;
      align-items:center;
      gap:8px;
      position:relative;
    }
    .date-field input[type="text"]{ flex:1; }
    .datebtn{
      width:40px;
      height:40px;
      border-radius:12px;
      border:1px solid var(--border-strong);
      background:#fff;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow:0 2px 10px rgba(15,23,42,.04);
      flex:0 0 auto;
    }
    .datebtn:hover{
      border-color:rgba(57,169,0,.35);
      box-shadow:0 10px 22px rgba(2,6,23,.08);
    }
    .datebtn svg{ width:18px; height:18px; fill:#0f172a; opacity:.9; }
    .dateiso{
      position:absolute;
      width:1px; height:1px;
      opacity:0;
      left:0; top:0;
    }

    .obs-restricciones{
      margin:8px 0 0 18px;
      padding:0;
      color:var(--danger);
      font-size:12px;
      font-weight:800;
    }
    .obs-restricciones li{ margin:4px 0; }
    .obs-restricciones li.obs-yellow{ color:#b45309; font-weight:800; }
    .input-invalid{ border-color:var(--danger)!important; box-shadow:0 0 0 2px rgba(220,38,38,.18)!important; }
    .field-error{ margin-top:4px; color:var(--danger); font-size:11px; font-weight:700; }
    
    #empresaMunicipio, #empresaDpto{ text-align:left; }
    .inline{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
    }
    .chk{
      display:flex; align-items:center; gap:8px;
      user-select:none;
      font-size:13px; font-weight:700;
      color:#334155;
    }
    .chk input{width:18px; height:18px}

    .actions{
      display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;
      margin-top:10px;
    }
    .btn{
      border:none;
      border-radius:12px;
      padding:10px 14px;
      font-weight:900;
      font-size:13px;
      cursor:pointer;
      transition:transform .08s ease, box-shadow .12s ease;
      display:inline-flex; align-items:center; gap:8px;
    }
        .btn.compact{padding:8px 10px; font-size:12px; border-radius:10px}
.btn:active{transform:translateY(1px)}
    .btn.primary{background:var(--green-base); color:#fff; box-shadow:0 10px 20px rgba(57,169,0,.20)}
    .btn.primary:hover{background:var(--green-soft)}
    .btn.outline{background:#fff; border:1px solid var(--border-strong); color:#0f172a}
    .btn.outline:hover{border-color:#c7f9d0}
    .btn.danger{background:#b91c1c; color:#fff}
    .btn[disabled]{opacity:.55; cursor:not-allowed}

    .hr{height:1px; background:var(--border); margin:14px 0}

    /* Overlay / Modal */
    .overlay{
      position:fixed; inset:0;
      background:rgba(2,6,23,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:50;
    }
    .overlay.show{display:flex}
    .modal{
      width:min(920px, 96vw);
      background:#fff;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.15);
      box-shadow:0 30px 60px rgba(2,6,23,.35);
      overflow:hidden;
    }
    .modal-header{
      padding:14px 16px;
      background:linear-gradient(180deg, rgba(57,169,0,.14), rgba(255,255,255,1));
      border-bottom:1px solid var(--border);
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .modal-header h3{margin:0; font-size:14px}
    .modal-body{padding:16px}
    .drop{
      border:2px dashed rgba(57,169,0,.50);
      border-radius:18px;
      padding:18px;
      background:rgba(57,169,0,.06);
      display:flex; flex-direction:column; gap:10px;
      align-items:center; justify-content:center;
      min-height:180px;
      text-align:center;
    }
    .drop strong{font-size:14px}
    .drop .small{font-size:12px; color:var(--muted)}
    .drop input{display:none}
    .drop .btn{margin-top:6px}

    .sig-preview{
      width:100%;
      max-width:360px;
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px;
      background:#f8fafc;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:110px;
    }
    .sig-preview img{max-width:100%; max-height:95px}

    /* Calendar modal */
    #calendarModal .modal{width:min(1120px, 98vw)}
    .cal-top{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .cal-top .summary{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .mini-wrap{
      display:grid;
      grid-template-columns: repeat(4, minmax(220px, 1fr));
      gap:12px;
    }
    @media (max-width: 1100px){ .mini-wrap{grid-template-columns: repeat(3, minmax(220px, 1fr));} }
    @media (max-width: 860px){ .mini-wrap{grid-template-columns: repeat(2, minmax(220px, 1fr));} }
    @media (max-width: 540px){ .mini-wrap{grid-template-columns: 1fr;} }

    .mini-month{
      border:1px solid var(--border);
      border-radius:14px;
      overflow:hidden;
      background:#fff;
      box-shadow:0 10px 20px rgba(2,6,23,.04);
    }
    .mini-month-title{
      padding:10px 12px;
      font-weight:900;
      font-size:12px;
      letter-spacing:.8px;
      background:var(--green-base);
      color:#fff;
      text-align:center;
    }
    .mini-grid{
      display:grid;
      grid-template-columns: repeat(7, 1fr);
      gap:4px;
      padding:10px;
    }
    .mini-dow{
      text-align:center;
      font-size:11px;
      font-weight:900;
      color:#64748b;
    }
    .mini-day{
      height:30px;
      border-radius:7px;
      display:flex; align-items:center; justify-content:center;
      font-size:12px;
      background:#e5e7eb;
      border:1px solid #d1d5db;
      color:#111827;
      cursor:pointer;
      user-select:none;
    }
    .mini-day.empty{visibility:hidden}
    .mini-day.inrange{background:rgba(57,169,0,.08); border-color:rgba(57,169,0,.25);}
    .mini-day.nonwork{
      background:#f1f5f9;
      color:#94a3b8;
      border-color:#e2e8f0;
      cursor:not-allowed;
    }
    .mini-day.selected{
      background:#39a900;
      border-color:rgba(57,169,0,.75);
      color:#ffffff;
      cursor:pointer;
      font-weight:900;
    }
    .mini-day.excluded{
      background:#e5e7eb;
      border-color:#991b1b;
      color:#ffffff;
      cursor:pointer;
      font-weight:900;
    }
    .mini-day.removed{
      background:#e5e7eb;
      border-color:#d1d5db;
      color:#6b7280;
      cursor:pointer;
      font-weight:900;
    }
.mini-day.busy{
      background:rgba(185,28,28,.10);
      border-color:rgba(185,28,28,.35);
      color:var(--danger);
      cursor:not-allowed;
      font-weight:900;
    }
    .mini-day.sel-left{border-top-left-radius:20px; border-bottom-left-radius:20px}
    .mini-day.sel-right{border-top-right-radius:20px; border-bottom-right-radius:20px}
    .mini-day.active-day{
      outline:3px solid rgba(57,169,0,.25);
      outline-offset:0px;
    }
    .mini-day.partialbusy{
      background:#f59e0b;
      border-color:rgba(245,158,11,.75);
      color:#ffffff;
      cursor:pointer;
      font-weight:900;
    }
    .mini-day.fullbusy{
      background:#e5e7eb;
      border-color:#991b1b;
      color:#ffffff;
      cursor:pointer;
      font-weight:900;
    }
    .mini-day.out{
      background:#fff;
      color:#94a3b8;
      cursor:default;
    }

    .mini-day.sel-mid{border-radius:7px}

    .list-days{
      margin-top:12px;
      border:1px solid var(--border);
      border-radius:14px;
      overflow:hidden;
    }
    .list-days .head{
      padding:10px 12px;
      background:#f8fafc;
      border-bottom:1px solid var(--border);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:900; font-size:12px;
    }
    table{
      width:100%;
      border-collapse:collapse;
      font-size:13px;
    }
    th, td{
      border-bottom:1px solid #f1f5f9;
      padding:10px 12px;
      vertical-align:top;
    }
    th{background:#fff; color:#334155; font-size:12px; text-transform:uppercase; letter-spacing:.4px}
    tr:hover td{background:#fbfdff}
    .linklike{color:#0ea5e9; font-weight:900; cursor:pointer; text-decoration:none}
    .linklike:hover{text-decoration:underline}

    .toast{
      position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      background:#0f172a;
      color:#fff;
      padding:10px 14px;
      border-radius:999px;
      box-shadow:0 20px 40px rgba(2,6,23,.30);
      display:none;
      z-index:90;
      font-weight:800;
      font-size:13px;
    }
    .toast.show{display:block}
  
    /* Autocomplete (programa por nombre) */
    .autocomplete{ position:relative; }
    .ac-list{
      position:absolute;
      top:calc(100% + 6px);
      left:0; right:0;
      border:1px solid var(--border);
      background:#fff;
      border-radius:12px;
      box-shadow:0 8px 28px rgba(2,6,23,.12);
      max-height:260px;
      overflow:auto;
      z-index:50;
    }
    .ac-item{
      padding:10px 12px;
      cursor:pointer;
      border-bottom:1px solid rgba(148,163,184,.35);
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .ac-item:last-child{ border-bottom:none; }
    .ac-item:hover{ background:#f1f5f9; }
    .ac-item .topline{ display:flex; justify-content:space-between; gap:10px; }
    .ac-item .name{ font-weight:700; color:#0f172a; }
    .ac-item .meta{ font-size:12px; color:var(--muted); }

    
    .badge.ok{
      border-color: rgba(16,185,129,.28);
      background: rgba(16,185,129,.12);
      color: #065f46;
    }

/* Calendar + hour blocks */
    .cal-grid{
      display:grid;
      grid-template-columns: 1.6fr .9fr;
      gap:12px;
      align-items:start;
    }
    @media (max-width: 980px){
      .cal-grid{ grid-template-columns: 1fr; }
    }
    .hour-panel{
      border:1px solid var(--border);
      border-radius:14px;
      background:#fff;
      padding:12px;
    }
    .hour-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .hour-day{ font-weight:800; font-size:14px; color:#0f172a; }
    .chk{ display:flex; align-items:center; gap:8px; font-size:13px; color:#0f172a; user-select:none; }
    .chk input{ transform:translateY(1px); }
    .hour-list{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
      gap:10px;
      max-height:360px;
      overflow:auto;
      padding-right:6px;
    }
    .hour-item{
      border:1px solid rgba(148,163,184,.45);
      border-radius:12px;
      padding:10px 10px;
      min-height:68px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      gap:6px;
      background:#f8fafc;
      cursor:pointer;
      user-select:none;
    }
    .hour-item.on{
      background:rgba(57,169,0,.22);
      border-color:rgba(57,169,0,.65);
      color:var(--green-dark);
    }
    .hour-item input{ display:none; }
    .hour-item.disabled{
      opacity:.55;
      cursor:pointer;
      background:#f1f5f9;
    }
        .hour-item.busy{
      opacity:1;
      cursor:pointer;
      background:#991b1b;
      border-color:#991b1b;
      color:#ffffff;
    }
    .hour-item.busy .hsmall{ color:#ffffff; opacity:.95; }
.hour-item .hlabel{ font-weight:900; font-size:14px; color:inherit; }
    .hour-item .hsmall{ font-size:12px; color:var(--muted); } 
    .hour-item.on .hsmall{ color:#0f172a; opacity:.9; }

    /* Estados visuales del calendario */
    .d.busyfull{ background:#fff1f2; border-color:rgba(239,68,68,.35); color:#991b1b; }
    .d.busypart{ background:#fffbeb; border-color:rgba(245,158,11,.35); color:#92400e; }
    .d.active-day{ outline:3px solid rgba(16,185,129,.22); }


    /* === PATCH A1-A6 === */
    /* Observaciones: advertencias amarillas */
    .obs-advertencias{
      margin-top:8px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(180,83,9,.35);
      background:rgba(245,158,11,.12);
      color:#b45309;
      font-weight:800;
      font-size:12.5px;
      line-height:1.25;
    }
    .obs-advertencias .item{ margin:2px 0; }

    /* Calendario: estilo similar al adjunto */
    .mini-wrap{
      display:grid;
      grid-template-columns: repeat(2, minmax(280px, 1fr));
      gap:16px;
    }
    @media (max-width: 980px){
      .mini-wrap{ grid-template-columns: 1fr; }
    }
    .mini-month{
      border:1px solid var(--border);
      border-radius:16px;
      overflow:hidden;
      background:#fff;
      box-shadow:0 16px 34px rgba(2,6,23,.08);
      padding:10px;
    }
    .mini-month-title{
      margin:0 0 10px 0;
      padding:10px 12px;
      font-weight:900;
      font-size:13px;
      letter-spacing:.9px;
      text-transform:uppercase;
      background:var(--green-base);
      color:#fff;
      border-bottom:none;
      border-radius:12px;
      text-align:center;
    }
    .mini-grid{
      display:grid;
      grid-template-columns: repeat(7, 1fr);
      gap:6px;
      padding:0 2px 4px;
    }
    .mini-dow{
      text-align:center;
      font-size:11px;
      font-weight:900;
      color:#64748b;
      letter-spacing:.4px;
      padding:2px 0 4px;
    }
    .mini-day{
      height:32px;
      border-radius:10px;
      display:flex; align-items:center; justify-content:center;
      font-size:13px;
      border:1px solid #e5e7eb;
      background:#fff;
      cursor:default;
      user-select:none;
      font-weight:900;
      color:#0f172a;
    }
    .mini-day.empty{visibility:hidden}
    .mini-day.inrange{ background:rgba(57,169,0,.10); border-color:rgba(57,169,0,.22); }
    .mini-day.selected{
      background:#39a900;
      border-color:rgba(57,169,0,.75);
      color:#ffffff;
      cursor:pointer;
      font-weight:900;
    }
    .mini-day.selected.partialbusy{
      background:#f59e0b;
      border-color:rgba(245,158,11,.75);
      color:#ffffff;
      cursor:pointer;
      font-weight:900;
    }
    .mini-day.excluded{
      background:#e5e7eb;
      border-color:#991b1b;
      color:#ffffff;
      cursor:pointer;
      font-weight:900;
    }
    .mini-day.removed{
      background:#e5e7eb;
      border-color:#d1d5db;
      color:#6b7280;
      cursor:pointer;
      font-weight:900;
    }
.mini-day.nonwork{
      background:#f1f5f9;
      color:#94a3b8;
      border-color:#e2e8f0;
      cursor:not-allowed;
    }
    .mini-day.busy{
      background:rgba(185,28,28,.12);
      border-color:rgba(185,28,28,.25);
      color:var(--danger);
      cursor:not-allowed;
      font-weight:900;
    }
    /* neutralizar "conexión" para que no se vea como banda */
    .mini-day.sel-left, .mini-day.sel-right, .mini-day.sel-mid{ border-radius:10px; }

    /* Footer fijo (diseño y desarrollo) */
    body.has-dev-footer{ padding-bottom: 0; }
    .dev-footer-wrap{
      position:relative;
      display:flex;
      justify-content:center;
      padding:0 16px 24px;
      margin-top:12px;
      z-index:auto;
    }
    .dev-footer{
      pointer-events:auto;
      width:min(980px, 92vw);
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius:999px;
      box-shadow:0 18px 40px rgba(2,6,23,.12);
      padding:10px 14px;
      display:flex;
      align-items:center;
      gap:12px;
    }
    .dev-footer .df-btn{
      width:40px; height:40px;
      border-radius:9999px;
      display:flex; align-items:center; justify-content:center;
      border:none;
      cursor:pointer;
      font-weight:900;
    }
    .dev-footer .df-btn.close{ background:#f97316; color:#fff; }
    .dev-footer .df-btn.gear{ background:rgba(59,130,246,.12); color:#2563eb; border:1px solid rgba(59,130,246,.25); }
    .dev-footer .df-text{ flex:1; line-height:1.1; }
    .dev-footer .df-title{ font-size:12px; letter-spacing:.18em; color:#94a3b8; font-weight:900; text-transform:uppercase; }
    .dev-footer .df-sub{ font-size:13px; color:#334155; font-weight:900; }
    .dev-footer .df-name{ font-size:15px; color:#0f172a; font-weight:900; }
    
</style>
</head>
<body>

<header>
  <div class="header-inner">
    <div class="logo" aria-hidden="true"><img src="https://oficinavirtualderadicacion.sena.edu.co/oficinavirtual/Resources/logoSenaNaranja.png" alt="" /></div>
    <div class="titleblock">
      <div class="t1">Servicio Nacional de Aprendizaje – SENA • Regional Tolima</div>
      <div class="t2">Generador de Fichas de Caracterización (Cursos Complementarios)</div>
      <div class="t3">2026 • Control de festivos, domingos y solapamientos de horario entre fichas</div>
    </div>
  </div>
</header>

<main>
  <div class="grid">
    <!-- Sidebar -->
    <div class="card">
      <div class="card-header">
        <h2>Fichas</h2>
        <span id="sidebarBadge" class="badge">Sin iniciar</span>
      </div>
      <div class="card-body">
        <div class="section">
          <div class="section-title">Instructor</div>
          <div class="hint" id="instructorSummary">Cargue el catálogo y diligencie la información inicial.</div>
        </div>
        <div class="hr"></div>
        <div class="section">
          <div class="section-title">Cursos</div>
          <div class="step-list" id="courseSteps"></div>
          <div class="hint" id="courseHint">Primero finalice el paso inicial.</div>
        </div>
        <div class="hr"></div>
        <div class="actions">
          <button class="btn outline" id="btnReiniciar" type="button">Reiniciar</button>
          <button class="btn primary" id="btnGenerarPDFs" type="button" disabled>Generar PDF(s)</button>
        </div>
        <div class="hint" id="pdfHint">Se habilita cuando todas las fichas estén guardadas.</div>
        <div class="pdf-month-summary" id="pdfMonthSummary" style="display:none;"></div>
      </div>
    </div>

    <!-- Main form -->
    <div class="card">
      <div class="card-header">
        <h2 id="mainTitle">Ficha</h2>
        <span id="mainBadge" class="badge">—</span>
      </div>
      <div class="card-body">
        <div id="emptyState" class="hint">
          Para iniciar: cargue el archivo <strong>CATALOGO_COMPLEMENTARIA.xlsx</strong> y diligencie la información del instructor.
        </div>

        <div id="courseFormWrap" style="display:none;">
          <div class="section">
            <div class="section-title">Datos del programa</div>
            <div class="form">
              <div class="field col4">
                <label>Código Programa de Formación <span class="req">*</span></label>
                <input id="programCode" type="text" placeholder="Ej: 51240078" />
                <div class="hint" id="programCodeHint"></div>
              </div>
                            <div class="field col8">
                <label>Nombre Programa de Formación <span class="req">*</span></label>
                <div class="autocomplete">
                  <input id="programName" type="text" placeholder="Escriba para buscar (nombre o parte del nombre)" autocomplete="off" />
                  <div class="ac-list" id="programNameList" style="display:none;"></div>
                </div>
                <div class="hint" id="programNameHint"></div>
              </div>
              <div class="field col3">
                <label>Horas (Duración) <span class="req">*</span></label>
                <input id="programHours" type="number" readonly />
              </div>
              <div class="field col9">
                <label>Área Ocupación <span class="req">*</span></label>
                <input id="areaOcupacion" type="text" readonly />
              </div>
              <div class="field col3" style="display:none;">
                <label>N° Ficha Caracterización</label>
                <input id="numFichaCaracterizacion" type="text" placeholder="(Opcional)" />
              </div>
              <div class="field col3" style="display:none;">
                <label>Código Empresa</label>
                <input id="codigoEmpresa" type="text" placeholder="(Opcional)" />
              </div>
            </div>
          </div>

          <div class="hr"></div>

          <div class="section">
            <div class="section-title">Información de la empresa</div>

            <div class="inline" style="justify-content:space-between;">
              <label class="chk">
                <input id="chkEmpresa" type="checkbox" />
                Ingresar datos completos de empresa (convenio / contacto)
              </label>
              <span class="hint">Si no activa el check, se diligencian valores predeterminados.</span>
            </div>

            <div class="form" style="margin-top:10px;">
              <div class="field full" id="empresaNombreWrap">
                <label>Nombre de empresa <span class="req">*</span></label>
                <input id="empresaNombre" type="text" placeholder="Razón social" />
              </div>
              <div class="field col4" id="empresaConvenioWrap">
                <label>Convenio</label>
                <input id="empresaConvenio" type="text" placeholder="Ej: Convenio 2026-XXX" />
              </div>
              <div class="field col8">
                <label>Aula (Dirección detallada) <span class="req">*</span></label>
                <input id="empresaAula" type="text" placeholder="Dirección / sede / aula" />
              </div>
              <div class="field col6" id="empresaContactoWrap">
                <label>Nombre del contacto de la empresa <span class="req">*</span></label>
                <input id="empresaContacto" type="text" placeholder="Nombre completo" />
              </div>
              <div class="field col3" id="empresaCelWrap">
                <label>Celular empresa</label>
                <input id="empresaCelular" type="text" placeholder="Ej: 3XX XXX XXXX" />
              </div>
              <div class="field col3" id="empresaCorreoWrap">
                <label>Correo empresa</label>
                <input id="empresaCorreo" type="email" placeholder="correo@empresa.com" />
              </div>
              <div class="field col4">
                <label>Municipio <span class="req">*</span></label>
                <select id="empresaMunicipio"></select>
              </div>
              <div class="field col4">
                <label>Departamento</label>
                <input id="empresaDpto" type="text" value="Tolima" readonly />
              </div>
            </div>

            <div class="hint" id="empresaDefaultsHint" style="margin-top:8px;"></div>
          </div>

          <div class="hr"></div>

          <div class="section">
            <div class="section-title">Programación</div>
            <div class="form">
              <div class="field col3">
                <label>Hora Inicio <span class="req">*</span></label>
                <select id="horaInicio">
                  <option value="">Seleccione…</option>
                  <option value="00:00">00:00</option>
                  <option value="01:00">01:00</option>
                  <option value="02:00">02:00</option>
                  <option value="03:00">03:00</option>
                  <option value="04:00">04:00</option>
                  <option value="05:00">05:00</option>
                  <option value="06:00">06:00</option>
                  <option value="07:00">07:00</option>
                  <option value="08:00">08:00</option>
                  <option value="09:00">09:00</option>
                  <option value="10:00">10:00</option>
                  <option value="11:00">11:00</option>
                  <option value="12:00">12:00</option>
                  <option value="13:00">13:00</option>
                  <option value="14:00">14:00</option>
                  <option value="15:00">15:00</option>
                  <option value="16:00">16:00</option>
                  <option value="17:00">17:00</option>
                  <option value="18:00">18:00</option>
                  <option value="19:00">19:00</option>
                  <option value="20:00">20:00</option>
                  <option value="21:00">21:00</option>
                  <option value="22:00">22:00</option>
                  <option value="23:00">23:00</option>
                </select>
<div class="hint">En bloques de 1 hora.</div>
              </div>
              <div class="field col3">
                <label>Hora Fin <span class="req">*</span></label>
                <select id="horaFin">
                  <option value="">Seleccione…</option>
                  <option value="00:00">00:00</option>
                  <option value="01:00">01:00</option>
                  <option value="02:00">02:00</option>
                  <option value="03:00">03:00</option>
                  <option value="04:00">04:00</option>
                  <option value="05:00">05:00</option>
                  <option value="06:00">06:00</option>
                  <option value="07:00">07:00</option>
                  <option value="08:00">08:00</option>
                  <option value="09:00">09:00</option>
                  <option value="10:00">10:00</option>
                  <option value="11:00">11:00</option>
                  <option value="12:00">12:00</option>
                  <option value="13:00">13:00</option>
                  <option value="14:00">14:00</option>
                  <option value="15:00">15:00</option>
                  <option value="16:00">16:00</option>
                  <option value="17:00">17:00</option>
                  <option value="18:00">18:00</option>
                  <option value="19:00">19:00</option>
                  <option value="20:00">20:00</option>
                  <option value="21:00">21:00</option>
                  <option value="22:00">22:00</option>
                  <option value="23:00">23:00</option>
                </select>
<div class="hint">En bloques de 1 hora.</div>
              </div>
              <div class="field col3">
                <label>Fecha Inicio <span class="req">*</span></label>
                <div class="date-field">
                  <input id="fechaInicioTxt" type="text" inputmode="numeric" placeholder="DD/MM/AAAA" autocomplete="off" />
                  <button class="datebtn" id="fechaInicioBtn" type="button" aria-label="Abrir selector de fecha de inicio">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                      <path d="M7 2a1 1 0 0 1 1 1v1h8V3a1 1 0 1 1 2 0v1h1.5A2.5 2.5 0 0 1 22 6.5v13A2.5 2.5 0 0 1 19.5 22h-15A2.5 2.5 0 0 1 2 19.5v-13A2.5 2.5 0 0 1 4.5 4H6V3a1 1 0 0 1 1-1Zm12.5 6H4.5a.5.5 0 0 0-.5.5v11a.5.5 0 0 0 .5.5h15a.5.5 0 0 0 .5-.5v-11a.5.5 0 0 0-.5-.5ZM7 12h4v4H7v-4Z"></path>
                    </svg>
                  </button>
                  <input id="fechaInicio" type="date" class="dateiso" tabindex="-1" aria-hidden="true" />
                </div>
              </div>
              <div class="field col3">
                <label>Fecha Finalización <span class="req">*</span></label>
                <div class="date-field">
                  <input id="fechaFinTxt" type="text" inputmode="numeric" placeholder="DD/MM/AAAA" autocomplete="off" />
                  <button class="datebtn" id="fechaFinBtn" type="button" aria-label="Abrir selector de fecha de finalización">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                      <path d="M7 2a1 1 0 0 1 1 1v1h8V3a1 1 0 1 1 2 0v1h1.5A2.5 2.5 0 0 1 22 6.5v13A2.5 2.5 0 0 1 19.5 22h-15A2.5 2.5 0 0 1 2 19.5v-13A2.5 2.5 0 0 1 4.5 4H6V3a1 1 0 0 1 1-1Zm12.5 6H4.5a.5.5 0 0 0-.5.5v11a.5.5 0 0 0 .5.5h15a.5.5 0 0 0 .5-.5v-11a.5.5 0 0 0-.5-.5ZM13 12h4v4h-4v-4Z"></path>
                    </svg>
                  </button>
                  <input id="fechaFin" type="date" class="dateiso" tabindex="-1" aria-hidden="true" />
                </div>
              </div>


              <div class="field full" id="weekdaysCalcWrap">
                <label>Días a programar <span class="req">*</span></label>
                <div class="dow-select" role="group" aria-label="Días a programar (LU–SA)">
                  <label class="dow-col"><span class="dow-name">LU</span><input type="checkbox" id="dowLU" checked></label>
                  <label class="dow-col"><span class="dow-name">MA</span><input type="checkbox" id="dowMA" checked></label>
                  <label class="dow-col"><span class="dow-name">MI</span><input type="checkbox" id="dowMI" checked></label>
                  <label class="dow-col"><span class="dow-name">JU</span><input type="checkbox" id="dowJU" checked></label>
                  <label class="dow-col"><span class="dow-name">VI</span><input type="checkbox" id="dowVI" checked></label>
                  <label class="dow-col"><span class="dow-name">SA</span><input type="checkbox" id="dowSA" checked></label>
                </div>
                <div class="inline" style="gap:10px; margin-top:8px; align-items:center;">
                  <label class="chk"><input type="checkbox" id="chkHorario2"><span>+ Añadir Horario Complementario</span></label>
                  <button class="btn primary" id="btnCalcularDias" type="button">Calcular</button>
                  <span class="hint" id="calcHint">Seleccione al menos un día (LU–SA) y presione Calcular para ver el detalle.</span>
                </div>
              
                <div class="comp-panel" id="horario2Panel" style="display:none;">
                  <div class="hint"><strong>Horario Complementario</strong> (hereda Fecha Inicio y Fecha Finalización)</div>
                  <div class="comp-grid">
                    <div class="field col3">
                      <label>Hora Inicio 2 <span class="req">*</span></label>
                      <select id="horaInicio2"></select>
                    </div>
                    <div class="field col3">
                      <label>Hora Fin 2 <span class="req">*</span></label>
                      <select id="horaFin2"></select>
                    </div>
                    <div class="field full">
                      <label>Días 2 <span class="req">*</span></label>
                      <div class="dow-select" role="group" aria-label="Días 2 (LU–SA)">
                        <label class="dow-col"><span class="dow-name">LU</span><input type="checkbox" id="dow2LU"></label>
                        <label class="dow-col"><span class="dow-name">MA</span><input type="checkbox" id="dow2MA"></label>
                        <label class="dow-col"><span class="dow-name">MI</span><input type="checkbox" id="dow2MI"></label>
                        <label class="dow-col"><span class="dow-name">JU</span><input type="checkbox" id="dow2JU"></label>
                        <label class="dow-col"><span class="dow-name">VI</span><input type="checkbox" id="dow2VI"></label>
                        <label class="dow-col"><span class="dow-name">SA</span><input type="checkbox" id="dow2SA"></label>
                      </div>
                      <div class="hint">Nota: No pide fechas. Usa el mismo rango de fechas del Horario principal.</div>
                    </div>
                  </div>
                </div>
</div>


              <div class="field col3">
                <label>Cupo <span class="req">*</span></label>
                <input id="cupo" type="number" min="1" step="1" placeholder="Ej: 30" />
                <div class="hint" id="cupoHint"></div>
              </div>
              <div class="field col9">
                <label>Observaciones</label>
                <textarea id="observaciones" placeholder="(Opcional)"></textarea>
                <ol id="obsRestricciones" class="obs-restricciones" style="display:none;"></ol>
                <div id="obsAdvertencias" class="obs-advertencias" style="display:none;"></div>
              </div>
            </div>

            <div class="actions" style="justify-content:flex-start; margin-top:12px;">
              <button class="btn outline" id="btnSeleccionarDias" type="button">Seleccionar días (calendario)</button>
              <span class="hint" id="diasHint">Selecciona un rango válido y horas antes de abrir el calendario.</span>
            </div>

            <div class="list-days" id="daysListWrap" style="display:none;">
              <div class="head">
                <div>Detalle de días programados</div>
                <div class="inline">
                  <span id="hoursBadge" class="badge">0 / 0 horas</span>
                  <span id="approxDateBadge" class="badge yellow" style="display:none;"></span>
                  <button class="btn primary compact" id="btnGuardar" type="button">Guardar ficha</button>
                  <a id="lnkReabrirCalendario" class="linklike">Editar días</a>
                </div>
              </div>
              <div style="overflow:auto;">
                <table>
                  <thead>
                    <tr>
                      <th style="width:160px;">Fecha</th>
                      <th style="width:170px;">Día</th>
                      <th style="width:170px;">Horario</th>
                      <th style="width:120px;">Horas/día</th>
                      <th>Acción</th>
                    </tr>
                  </thead>
                  <tbody id="daysTbody"></tbody>
                </table>
              </div>
              <div class="hint" style="padding:10px 12px;" id="hoursRulesHint"></div>
            </div>
          </div>

          <div class="hr"></div>

          <div class="actions">
            <button class="btn outline" id="btnPrev" type="button">Anterior</button>
<button class="btn outline" id="btnNext" type="button">Siguiente</button>
          </div>
          <div class="hint" id="saveHint" style="margin-top:8px;"></div>
        </div>
      </div>
    </div>
  </div>
</main>


<!-- Footer (DISEÑO Y DESARROLLO) -->
<div class="dev-footer-wrap" id="devFooterWrap" aria-hidden="false" style="display:none;">
  <div class="dev-footer" role="contentinfo">
    <button class="df-btn close" type="button" id="btnDevFooterClose" aria-label="Cerrar">×</button>
    <div class="df-text">
      <div class="df-title">DISEÑO Y DESARROLLO</div>
      <div class="df-sub">INSTRUCTOR DISEÑADOR</div>
      <div class="df-name">Yeison Castellanos Gordillo</div>
    </div>
    <button class="df-btn gear" type="button" id="btnDevFooterGear" aria-label="Configuración">⚙</button>
  </div>
</div>


<!-- Overlay: archivo catálogo -->
<div class="overlay show" id="fileOverlay" role="dialog" aria-modal="true">
  <div class="modal">
    <div class="modal-header">
      <h3>1) Cargar catálogo (CATALOGO_COMPLEMENTARIA.xlsx)</h3>
      <button class="btn outline" type="button" id="btnDemoSkip" title="Cerrar">Cerrar</button>
    </div>
    <div class="modal-body">
      <div class="drop" id="dropZone">
        <strong id="autoCatalogTitle">Cargando catálogo automáticamente…</strong>
        <div class="small" id="autoCatalogSub">Buscando <strong>CATALOGO_COMPLEMENTARIA.xlsx</strong> en la misma carpeta.</div>

        <div id="manualCatalogLoad" style="display:none; margin-top:10px;">
          <div class="small" style="margin-bottom:8px;">
            No fue posible cargar el catálogo automáticamente. Para que la auto-carga funcione, abra este HTML desde un servidor (por ejemplo, un servidor local).
            Como respaldo, seleccione el archivo manualmente:
          </div>
          <input id="fileInput" type="file" accept=".xlsx,.xls" />
          <button class="btn primary" type="button" id="btnPickFile">Seleccionar archivo</button>
        </div>

        <div class="hint" id="fileStatus"></div>
      </div>
    </div>
  </div>
</div>

<!-- Overlay: info instructor -->
<div class="overlay" id="instructorOverlay" role="dialog" aria-modal="true">
  <div class="modal">
    <div class="modal-header">
      <h3>2) Información del Instructor(a)</h3>
      <button class="btn outline" type="button" id="btnCloseInstructor" title="Cerrar">Cerrar</button>
    </div>
    <div class="modal-body">
      <div class="form">
        <div class="field full">
          <label>Nombre Completo <span class="req">*</span></label>
          <input id="instNombre" type="text" tabindex="1" list="instNombreList" autocomplete="off" />
          <datalist id="instNombreList"></datalist>
          <div class="hint" id="instDbStatus"></div>
          <input id="instDBInput" type="file" accept=".xls,.xlsx" style="display:none" />
          <button class="btn outline" type="button" id="btnLoadInstructores" style="margin-top:6px; display:none;">Cargar base Instructores.xls</button>
        </div>
        <div class="field col4">
  <label>N° Cédula <span class="req">*</span></label>
  <input id="instCedula" type="text" tabindex="2" />
</div>
<div class="field col4">
  <label>Celular <span class="req">*</span></label>
  <input id="instCelular" type="tel" placeholder="Ej: 3001234567" tabindex="3" />
</div>

<div class="field col4">
  <label><span id="instCorreoLabel">Correo SENA</span> <span class="req">*</span></label>
  <input id="instCorreo" type="email" placeholder="usuario@sena.edu.co" tabindex="4" />
  <label class="chk" style="gap:10px; margin-top:6px;">
    <input id="instCorreoActivo" type="checkbox" checked tabindex="5" />
    <span>Tiene correo SENA (Activo)</span>
  </label>
</div>

        <div class="field col6">
          <label>Coordinador(a) Académico(a) <span class="req">*</span></label>
          <select id="instCoordinador" tabindex="6">
            <option value="">Seleccione…</option>
            <option value="EDNA PAOLA OSORIO MUÑOZ">EDNA PAOLA OSORIO MUÑOZ</option>
            <option value="JORGE ARMANDO VARELA RENDÓN">JORGE ARMANDO VARELA RENDÓN</option>
            <option value="YOLANDA CÁRDENAS VILLAMARIN">YOLANDA CÁRDENAS VILLAMARIN</option>
          </select>
        </div>

        <div class="field col6">
          <label>¿Cuántos cursos desea generar? <span class="req">*</span></label>
          <select id="instNumCursos" tabindex="7">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
          </select>
          <div class="hint">Máximo 5.</div>
        </div>

        <div class="field full">
          <label>Firma (imagen) <span class="hint" style="font-weight:800; color:var(--muted);">(Opcional)</span></label>
          <input id="instFirma" type="file" accept="image/*" tabindex="8" />
          <div class="sig-preview" style="margin-top:8px;">
            <img id="firmaPreview" alt="Previsualización firma" style="display:none;" />
            <div id="firmaPlaceholder" class="hint">Cargue una imagen (PNG/JPG) con fondo blanco o transparente.</div>
          </div>
        </div>
      </div>

      <div class="actions">
        <button class="btn outline" type="button" id="btnBackToFile" tabindex="9">Volver</button>
        <button class="btn primary" type="button" id="btnContinuar" tabindex="10">Continuar</button>
      </div>
      <div class="hint" id="instructorStatus"></div>
    </div>
  </div>
</div>

<!-- Modal calendario -->
<div class="overlay" id="calendarModal" role="dialog" aria-modal="true">
  <div class="modal">
    <div class="modal-header">
      <h3 id="calTitle">Seleccionar programación</h3>
      <button class="btn outline" type="button" id="btnCloseCalendar">Cerrar</button>
    </div>
    <div class="modal-body">
      <div class="cal-top">
        <div class="summary">
          <span class="badge" id="calRangeBadge">—</span>
          <span class="badge" id="calNonWorkBadge">Domingos/Festivos bloqueados</span>
          <span class="badge warn" id="calBusyBadge" style="display:none;">Hay horas ocupadas por otras fichas</span>
        </div>
        <div class="actions" style="margin:0;">
          <button class="btn outline" type="button" id="btnSelectAll">Seleccionar todo</button>
          <button class="btn outline" type="button" id="btnClearAll">Quitar todo</button>
          <button class="btn primary" type="button" id="btnGuardarDias">Guardar</button>
        </div>
      </div>

      <div class="cal-grid">
        <div>
          <div class="mini-wrap" id="miniWrap"></div>
          <div class="inline" style="justify-content:space-between; margin-top:10px;">
            <div class="hint">
              Por defecto se seleccionan días hábiles (Lunes a Sábado). Haga clic en un día para activarlo y ajustar sus horas.
              Para <strong>quitar</strong> un día ya seleccionado: haga clic una vez para activarlo y una segunda vez para retirarlo.
            </div>
            <div class="badge" id="calHoursPreview">0 horas</div>
          </div>
        </div>

        <div class="hour-panel">
          <div class="hour-head">
            <div>
              <div class="small muted">Día activo</div>
              <div class="hour-day" id="activeDayLabel">—</div>
            </div>
            <label class="chk" title="Si está activo, los cambios de horas se aplican a todos los días seleccionados (respetando horas ocupadas).">
              <input type="checkbox" id="applyHoursToAll" checked />
              <span>Aplicar a todos los días</span>
            </label>
          </div>

          <div class="hr" style="margin:10px 0;"></div>

          <div class="hint" id="hourPanelHint">Seleccione un día del calendario para editar sus horas.</div>
          <div class="hour-list" id="hourList" style="display:none;"></div>

          <div class="inline" style="justify-content:space-between; margin-top:10px;">
            <div class="badge" id="dayHoursBadge">0 horas/día</div>
            <div class="actions" style="margin:0; gap:8px;">
              <button class="btn outline" type="button" id="btnDayAll">Todas</button>
              <button class="btn outline" type="button" id="btnDayNone">Ninguna</button>
            </div>
          </div>

          <div class="hint" id="hourRules" style="margin-top:10px;"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal: seleccionar programa por nombre (cuando hay duplicados) -->
<div class="overlay" id="programPickModal" role="dialog" aria-modal="true">
  <div class="modal" style="width:min(860px, 96vw);">
    <div class="modal-header">
      <h3>Seleccione el programa correcto</h3>
      <button class="btn outline" type="button" id="btnCloseProgramPick">Cerrar</button>
    </div>
    <div class="modal-body">
      <div class="hint" id="programPickHint" style="margin-bottom:10px;"></div>
      <div class="table-wrap" style="max-height:420px;">
        <table class="tbl">
          <thead>
            <tr>
              <th style="width:180px;">Código</th>
              <th>Nombre</th>
              <th style="width:120px;">Horas</th>
              <th style="width:140px;">Acción</th>
            </tr>
          </thead>
          <tbody id="programPickTbody"></tbody>
        </table>
      </div>
    </div>
  </div>
</div>


<!-- Modal informativo (cruces / disponibilidad) -->
<div class="overlay" id="infoOverlay" role="dialog" aria-modal="true" aria-label="Detalle de cruce">
  <div class="modal" style="max-width:640px;">
    <div class="modal-header">
      <h3 id="infoTitle">Detalle</h3>
      <button class="btn outline" type="button" id="btnInfoClose" title="Cerrar">Cerrar</button>
    </div>
    <div class="modal-body">
      <div id="infoBody" style="white-space:pre-line; line-height:1.35;"></div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<!-- Librerías (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.5.29/dist/jspdf.plugin.autotable.min.js"></script>

<script>
(function(){
  "use strict";

  // =========================
  // Utilidades
  // =========================
  const $ = (id) => document.getElementById(id);

  function toast(msg){
    const el = $("toast");
    el.textContent = msg;
    el.classList.add("show");
    clearTimeout(toast._t);
    toast._t = setTimeout(()=> el.classList.remove("show"), 2200);
  }

  
  function showInfo(title, body){
    const ov = $("infoOverlay");
    const tt = $("infoTitle");
    const bb = $("infoBody");
    if(!ov || !tt || !bb){
      toast(String(body||title||""));
      return;
    }
    tt.textContent = title || "Información";
    bb.textContent = body || "";
    ov.classList.add("show");
  }
  function hideInfo(){
    const ov = $("infoOverlay");
    if(ov) ov.classList.remove("show");
  }

  function hoursSetToRangesStrA(set){
    const arr = Array.from(set||[]).filter(n=>Number.isFinite(n)).sort((a,b)=>a-b);
    if(!arr.length) return "";
    const ranges = [];
    let s = arr[0], prev = arr[0];
    for(let i=1;i<arr.length;i++){
      const h = arr[i];
      if(h === prev + 1){ prev = h; continue; }
      ranges.push([s, prev+1]);
      s = h; prev = h;
    }
    ranges.push([s, prev+1]);
    return ranges.map(([a,b])=> `${pad2(a)}:00 a ${pad2(b)}:00`).join(" - ");
  }

  function conflictGroupsForHours(c, iso, hours){
    const groups = new Map();
    for(const h of hours){
      const e = isHourBusyPrior(iso, h, c.idx);
      if(!e) continue;
      const key = `${e.cursoIndex}|${e.ficha||""}|${e.label||""}`;
      if(!groups.has(key)){
        groups.set(key, { ficha: (e.ficha||"").trim(), label: e.label || "", hours: new Set() });
      }
      groups.get(key).hours.add(h);
    }
    return Array.from(groups.values()).map(g=>({
      ficha: g.ficha,
      label: g.label,
      hoursStr: hoursSetToRangesStrA(g.hours)
    }));
  }

  function conflictMessageForDay(c, iso){
    const hours = occupiedHoursPrior(iso, c.idx);
    const groups = conflictGroupsForHours(c, iso, hours);
    const fecha = fmtDMYYYY(iso);
    const lines = [`Fecha: ${fecha}`];
    if(!groups.length){
      lines.push("No hay detalle disponible del cruce.");
      return lines.join("\n");
    }
    lines.push("Se cruza con:");
    for(const g of groups){
      const fichaTxt = g.ficha ? `Ficha ${g.ficha}` : "Ficha (sin número)";
      const lbl = g.label ? ` • ${g.label}` : "";
      const hs = g.hoursStr ? ` • ${g.hoursStr}` : "";
      lines.push(`- ${fichaTxt}${lbl}${hs}`);
    }
    return lines.join("\n");
  }

  // Cruces solo dentro del horario seleccionado (Hora Inicio/Hora Fin) del curso actual
  function conflictGroupsForHours(courseIdx, iso, hoursArr){
    const groups = new Map(); // key -> { cursoIndex,label,hours:[] }
    for(const h of (hoursArr||[])){
      const e = isHourBusyPrior(iso, h, courseIdx);
      if(!e) continue;
      const key = `${e.cursoIndex}|${e.label}`;
      if(!groups.has(key)) groups.set(key, { cursoIndex:e.cursoIndex, label:e.label, hours:[] });
      groups.get(key).hours.push(h);
    }
    return Array.from(groups.values())
      .sort((a,b)=> a.cursoIndex - b.cursoIndex)
      .map(g=> ({...g, hoursStr: hoursSetToRangesStrA(new Set(g.hours))}));
  }

  function conflictMessageForDayInAllowedRange(c, iso){
    const allowed = allowedHoursFromCourse(c, iso);
    const busy = [];
    for(const h of allowed){
      if(isHourBusyPrior(iso, h, c.idx)) busy.push(h);
    }
    if(!busy.length) return "No se detectaron cruces en el horario actual para este día.";
    const groups = conflictGroupsForHours(c.idx, iso, busy);
    const lines = [];
    lines.push(`Fecha: ${fmtDMYYYY(iso)}`);
    lines.push("");
    for(const g of groups){
      lines.push(`${g.label} • ${g.hoursStr}`);
    }
    return lines.join("\n");
  }

  function partialAvailabilityMessage(c, iso){
    const allowed = allowedHoursFromCourse(c, iso);
    const busy = [];
    const free = [];
    for(const h of allowed){
      if(isHourBusyPrior(iso, h, c.idx)) busy.push(h);
      else free.push(h);
    }
    const groups = conflictGroupsForHours(c.idx, iso, busy);
    const lines = [];
    lines.push(`Fecha: ${fmtDMYYYY(iso)}`);
    lines.push("");
    if(groups.length){
      lines.push("Ocupado por:");
      for(const g of groups){
        lines.push(`- ${g.label} • ${g.hoursStr}`);
      }
    }else{
      lines.push("Ocupado: (sin detalle disponible)");
    }
    lines.push("");
    const freeStr = free.length ? hoursSetToRangesStrA(new Set(free)) : "Sin horas disponibles";
    lines.push(`Disponible: ${freeStr}`);
    lines.push("");
    lines.push("Nota: el sistema guardará únicamente las horas disponibles.");
    return lines.join("\n");
  }


  function conflictMessageForHour(c, iso, h){
    const e = isHourBusyPrior(iso, h, c.idx);
    const fecha = fmtDMYYYY(iso);
    const hr = `${pad2(h)}:00 a ${pad2(h+1)}:00`;
    if(!e) return `Fecha: ${fecha}\nHorario: ${hr}\nSin detalle del cruce.`;
    const fichaTxt = (e.ficha && String(e.ficha).trim()) ? `Ficha ${String(e.ficha).trim()}` : "Ficha (sin número)";
    const lbl = e.label ? ` • ${e.label}` : "";
    return `Fecha: ${fecha}\nHorario: ${hr}\nOcupado por: ${fichaTxt}${lbl}`;
  }

function escapeHtml(str){
    return (str ?? "").toString()
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#039;");
  }

  function normalizeFileNamePart(value){
    const str = (value ?? "").toString().trim();
    if(!str) return "";
    return str
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .replace(/[^a-zA-Z0-9]+/g, "_")
      .replace(/^_+|_+$/g, "")
      .replace(/_+/g, "_");
  }

  function parseISODate(iso){
    const v = (iso || "").trim();
    if(!v) return null;
    const parts = v.split("-").map(Number);
    if(parts.length !== 3) return null;
    const [y,m,d] = parts;
    if(!y || !m || !d) return null;
    return new Date(y, m - 1, d);
  }

  function formatISO(y,m,d){
    return String(y).padStart(4,"0") + "-" + String(m).padStart(2,"0") + "-" + String(d).padStart(2,"0");
  }

  
  function todayISO(){
    const t = new Date();
    return formatISO(t.getFullYear(), t.getMonth()+1, t.getDate());
  }

  // Suma días hábiles (LU–VI) a una fecha ISO (YYYY-MM-DD), sin contar sábados ni domingos.
  // Ej: si hoy es lunes 05/01/2026, +5 hábiles => lunes 12/01/2026.
  function addBusinessDaysISO(startISO, businessDays){
    if(!isISODateComplete(startISO)) return startISO;
    const n = Number(businessDays);
    if(!Number.isFinite(n) || n <= 0) return startISO;

    // Construir fecha en zona local evitando offset TZ
    let dt = new Date(startISO + "T00:00:00");
    dt.setHours(0,0,0,0);

    let added = 0;
    while(added < n){
      dt.setDate(dt.getDate() + 1);
      const dow = dt.getDay(); // 0=dom, 6=sáb
      if(dow !== 0 && dow !== 6) added++;
    }
    return formatISO(dt.getFullYear(), dt.getMonth()+1, dt.getDate());
  }

  function isISODateComplete(v){
    return /^\d{4}-\d{2}-\d{2}$/.test(String(v||""));
  }


function toDDMMYYYY(iso){
    const v = (iso || "").trim();
    const p = v.split("-");
    if(p.length !== 3) return v || "";
    return `${p[2]}/${p[1]}/${p[0]}`;
  }

  function fmtDMYYYY(v){
    if(!v) return "";
    if(v instanceof Date){
      const dd = String(v.getDate()).padStart(2,"0");
      const mm = String(v.getMonth()+1).padStart(2,"0");
      const yy = v.getFullYear();
      return `${dd}/${mm}/${yy}`;
    }
    return toDDMMYYYY(String(v));
  }

  function normalizeDMYInput(val){
    const raw = (val ?? "").toString().trim();
    if(!raw) return "";
    // Permite escribir solo números y "/" (si el usuario pega 8 dígitos, formatea automáticamente)
    const digits = raw.replace(/[^0-9]/g, "");
    if(digits.length === 8){
      return `${digits.slice(0,2)}/${digits.slice(2,4)}/${digits.slice(4)}`;
    }
    return raw.replace(/[^0-9/]/g, "");
  }

  function parseDMYToISO(dmy){
    const v = (dmy || "").trim();
    const m = v.match(/^(\d{2})\/(\d{2})\/(\d{4})$/);
    if(!m) return null;
    const dd = Number(m[1]), mm = Number(m[2]), yy = Number(m[3]);
    if(!Number.isFinite(dd) || !Number.isFinite(mm) || !Number.isFinite(yy)) return null;
    if(yy < 1900 || yy > 2100) return null;
    if(mm < 1 || mm > 12) return null;
    if(dd < 1 || dd > 31) return null;
    const dt = new Date(yy, mm-1, dd);
    dt.setHours(0,0,0,0);
    if(dt.getFullYear() !== yy || (dt.getMonth()+1) !== mm || dt.getDate() !== dd) return null;
    return formatISO(dt.getFullYear(), dt.getMonth()+1, dt.getDate());
  }


  function dayNameES(date){
    return date.toLocaleDateString("es-CO", { weekday:"long" });
  }

  function minutesFromHHMM(hhmm){
    const v = (hhmm || "").trim();
    if(!v) return null;
    const p = v.split(":").map(Number);
    if(p.length < 2) return null;
    const hh = p[0], mm = p[1];
    if(Number.isNaN(hh) || Number.isNaN(mm)) return null;
    return hh*60 + mm;
  }

  function hhmmFromMinutes(min){
    const hh = Math.floor(min/60);
    const mm = min%60;
    return String(hh).padStart(2,"0")+":"+String(mm).padStart(2,"0");
  }

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function datesBetweenInclusive(startDate, endDate){
    const out = [];
    const cur = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
    const end = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
    while(cur <= end){
      out.push(new Date(cur.getFullYear(), cur.getMonth(), cur.getDate()));
      cur.setDate(cur.getDate()+1);
    }
    return out;
  }

  // =========================
  // Datos fijos
  // =========================

  // Festivos nacionales Colombia 2026 (18)
  const FESTIVOS_2026 = new Set([
    "2026-01-01","2026-01-12","2026-03-23","2026-04-02","2026-04-03","2026-05-01",
    "2026-05-18","2026-06-08","2026-06-15","2026-06-29","2026-07-20","2026-08-07",
    "2026-08-17","2026-10-12","2026-11-02","2026-11-16","2026-12-08","2026-12-25"
  ]);

  const MONTH_NAMES = ["enero","febrero","marzo","abril","mayo","junio","julio","agosto","septiembre","octubre","noviembre","diciembre"];
  const DOWS = ["DO","LU","MA","MI","JU","VI","SA"];

  const MUNICIPIOS_TOLIMA = [
    "Ibagué",
    "Alpujarra","Alvarado","Ambalema","Anzoátegui","Armero","Ataco","Cajamarca","Carmen de Apicalá","Casabianca",
    "Chaparral","Coello","Coyaima","Cunday","Dolores","El Espinal","Falan","Flandes","Fresno","Guamo",
    "Herveo","Honda","Icononzo","Lérida","Líbano","Mariquita","Melgar","Murillo","Natagaima","Ortega",
    "Palocabildo","Piedras","Planadas","Prado","Purificación","Rioblanco","Roncesvalles","Rovira","Saldaña",
    "San Antonio","San Luis","Santa Isabel","Suárez","Valle de San Juan","Venadillo","Villahermosa","Villarrica"
  ];

  const EMPRESA_DEFAULTS = {
    nombre: "NO APLICA",
    convenio: "DEMANDA SOCIAL",
    contacto: "NO APLICA",
    celular: "NO APLICA",
    correo: "NO APLICA",
  };

  // =========================
  // Estado global
  // =========================
  const STATE = {
    catalogLoaded: false,
    catalogMap: new Map(), // code -> {name, hours}
    instructor: {
      nombre: "", cedula: "", celular: "", correo: "", coordinador: "", firmaDataUrl: ""
    },
    numCursos: 1,
    cursos: [], // array of curso
    activeIndex: 0,
    // ocupación: iso -> array {startMin,endMin,cursoIndex,label}
    occupancy: new Map(),
  };

  function makeCurso(i){
    return {
      idx: i,
      saved: false,
      program: { code:"", name:"", hours:null, aMedida:"" },
      meta: { area:"", ficha:"", codigoEmpresa:"" },
      empresa: {
        full: false,
        nombre: EMPRESA_DEFAULTS.nombre,
        convenio: EMPRESA_DEFAULTS.convenio,
        aula: "",
        contacto: EMPRESA_DEFAULTS.contacto,
        celular: EMPRESA_DEFAULTS.celular,
        correo: EMPRESA_DEFAULTS.correo,
        municipio: "Ibagué",
        dpto: "Tolima",
      },
      prog: { start:"", end:"", hStart:"", hEnd:"", cupo:"", obs:"", weekdays:[1,2,3,4,5,6], calculated:false, extra:{ enabled:false, hStart:"", hEnd:"", weekdays:[] } },
      days: {
        // en este modelo, seleccionados = días hábiles en rango - excluidos
        excluded: new Set(),
        selected: [], // array ISO
      },
      computed: { hoursPerDay: 0, totalHours: 0, nonWorkCount: 0, busyCount: 0 },
    };
  }

  // =========================
  // Inicialización UI
  // =========================
  function populateMunicipios(){
    const sel = $("empresaMunicipio");
    if(!sel) return;
    sel.innerHTML = "";
    MUNICIPIOS_TOLIMA.forEach(m => {
      const opt = document.createElement("option");
      opt.value = m;
      opt.textContent = m.toUpperCase();
      sel.appendChild(opt);
    });
    sel.value = "Ibagué";
  }

  populateMunicipios();

  // =========================
  // Overlay Catálogo
  // =========================
  const fileOverlay = $("fileOverlay");
  const instructorOverlay = $("instructorOverlay");
  const calendarModal = $("calendarModal");
  // Modal informativo (cruces)
  (function(){
    const closeBtn = $("btnInfoClose");
    const ov = $("infoOverlay");
    if(closeBtn) closeBtn.addEventListener("click", hideInfo);
    if(ov){
      ov.addEventListener("click", (ev)=>{
        if(ev.target === ov) hideInfo();
      });
    }
  })();



  const fileInput = $("fileInput");
  const dropZone = $("dropZone");
  const fileStatus = $("fileStatus");
  const manualCatalogLoad = $("manualCatalogLoad");
  const autoCatalogTitle = $("autoCatalogTitle");
  const autoCatalogSub = $("autoCatalogSub");

  $("btnPickFile").addEventListener("click", () => fileInput.click());
  $("btnDemoSkip").addEventListener("click", () => {
    // No permite avanzar sin catálogo; solo cierra visualmente.
    toast("Debe cargar el catálogo para continuar.");
  });

  fileInput.addEventListener("change", (e) => {
    const f = (e.target.files && e.target.files[0]) ? e.target.files[0] : null;
    if(f) handleCatalogFile(f);
  });

  ;["dragenter","dragover"].forEach(ev=>{
    dropZone.addEventListener(ev, (e)=>{ e.preventDefault(); e.stopPropagation(); dropZone.style.borderColor="rgba(57,169,0,.85)"; });
  });
  ;["dragleave","drop"].forEach(ev=>{
    dropZone.addEventListener(ev, (e)=>{ e.preventDefault(); e.stopPropagation(); dropZone.style.borderColor="rgba(57,169,0,.50)"; });
  });
  dropZone.addEventListener("drop", (e)=>{
    const f = (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0]) ? e.dataTransfer.files[0] : null;
    if(f) handleCatalogFile(f);
  });

  async function handleCatalogFile(file){
    fileStatus.textContent = "Leyendo archivo...";
    try{
      const buf = await file.arrayBuffer();
      const wb = XLSX.read(buf, { type:"array" });

      // Buscar una hoja (por defecto 'Reporte')
      const sheetName = wb.SheetNames[0];
      const ws = wb.Sheets[sheetName];
      const rows = XLSX.utils.sheet_to_json(ws, { header:1, defval:"" });

      if(!rows || rows.length < 2){
        throw new Error("La hoja no contiene datos suficientes.");
      }

      // Encabezados esperados:
      // A NIVEL_FORMACION, B CODIGO_PROGRAMA, D NOMBRE_PROGRAMA_FORMACION, E DURACION_PROGRAMA
      const header = rows[0].map(v => String(v).trim());
      const idxCode = header.indexOf("CODIGO_PROGRAMA");
      const idxName = header.indexOf("NOMBRE_PROGRAMA_FORMACION");
      const idxHours = header.indexOf("DURACION_PROGRAMA");

      let idxArea = header.indexOf("AREA_OCUPACION");
      if(idxArea < 0) idxArea = 5; // Columna F (según catálogo)

      const headerNorm = header.map(h => String(h||"").trim().toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,""));
      let idxMedida = headerNorm.indexOf("a la medida");
      if(idxMedida < 0) idxMedida = headerNorm.indexOf("a_la_medida");
      if(idxMedida < 0) idxMedida = 6; // Columna G (según catálogo)
      if(idxCode < 0 || idxName < 0 || idxHours < 0){
        throw new Error("No se encontraron las columnas esperadas: CODIGO_PROGRAMA, NOMBRE_PROGRAMA_FORMACION, DURACION_PROGRAMA.");
      }

      const map = new Map();
      for(let r=1; r<rows.length; r++){
        const row = rows[r];
        const code = String(row[idxCode] ?? "").trim();
        const name = String(row[idxName] ?? "").trim();
        const hours = Number(row[idxHours] ?? 0);
        const area = String(row[idxArea] ?? "").trim();
        const aMedida = String(row[idxMedida] ?? "").trim().toUpperCase();
        if(!code || !name || !hours) continue;
        map.set(code, { name, hours, area, aMedida });
      }

      if(map.size < 10){
        // el archivo real tiene mucho más; si está muy pequeño probablemente es otro.
        toast("Advertencia: catálogo con pocos registros. Verifique el archivo.");
      }

      STATE.catalogMap = map;
      STATE.catalogLoaded = true;

      fileStatus.textContent = `Catálogo cargado: ${map.size} programas.`;
      toast("Catálogo cargado.");

      // avanzar a instructor
      fileOverlay.classList.remove("show");
      instructorOverlay.classList.add("show");
      $("instructorStatus").textContent = "";

    }catch(err){
      console.error(err);
      fileStatus.textContent = "Error: " + (err && err.message ? err.message : String(err));
      toast("No se pudo leer el catálogo.");
    }
  }

  // =========================
  // Auto-carga del catálogo (misma carpeta)
  // =========================
  async function autoLoadCatalogSameFolder(){
    if(STATE.catalogLoaded) return;
    // En modo archivo (file://) los navegadores bloquean fetch() por CORS.
    // Use carga manual o abra el HTML desde un servidor local (http://localhost).
    if(location.protocol === "file:"){
      if(autoCatalogTitle) autoCatalogTitle.textContent = "Carga automática deshabilitada (modo archivo)";
      if(autoCatalogSub) autoCatalogSub.innerHTML = "Cargue el catálogo manualmente o ejecute el HTML desde un servidor local (http://localhost).";
      if(fileStatus) fileStatus.textContent = "Modo archivo: cargue el catálogo manualmente.";
      return;
    }
    const fname = "CATALOGO_COMPLEMENTARIA.xlsx";
    try{
      if(autoCatalogTitle) autoCatalogTitle.textContent = "Cargando catálogo automáticamente…";
      if(autoCatalogSub) autoCatalogSub.innerHTML = `Buscando <strong>${fname}</strong> en la misma carpeta.`;
      if(fileStatus) fileStatus.textContent = `Buscando ${fname} en la misma carpeta...`;

      const res = await fetch(fname, { cache: "no-store" });
      if(!res.ok) throw new Error(`No se encontró ${fname} (HTTP ${res.status}).`);
      const ab = await res.arrayBuffer();
      const file = new File([ab], fname, {
        type: res.headers.get("content-type") || "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
      });
      await handleCatalogFile(file); // maneja overlay y estado

      // Si cargó, ocultar respaldo manual por si quedó visible
      if(manualCatalogLoad) manualCatalogLoad.style.display = "none";
    }catch(err){
      console.warn("Auto-carga catálogo falló:", err);

      if(autoCatalogTitle) autoCatalogTitle.textContent = "Catálogo no cargado automáticamente";
      if(autoCatalogSub) autoCatalogSub.innerHTML = `No se pudo cargar <strong>${fname}</strong> desde la misma carpeta.`;
      if(fileStatus) fileStatus.textContent = `No se pudo cargar automáticamente ${fname}.`;

      // Mostrar respaldo manual SOLO si falla (por restricciones del navegador / file://)
      if(manualCatalogLoad) manualCatalogLoad.style.display = "block";
    }
  }

  // Intentar auto-carga al iniciar (si está disponible desde la misma carpeta/servidor)
  setTimeout(()=>{ autoLoadCatalogSameFolder(); }, 60);


  // =========================
  // Overlay Instructor
  // =========================
  const firmaInput = $("instFirma");
  const firmaPreview = $("firmaPreview");
  const firmaPlaceholder = $("firmaPlaceholder");

  // =========================
  // Base de Instructores (misma carpeta)
  // =========================
  const instDbStatus = $("instDbStatus");
  const instNombreEl = $("instNombre");
  const instCedulaEl = $("instCedula");
  const instCelularEl = $("instCelular");
  const instCorreoEl = $("instCorreo");
  const instCorreoActivoEl = $("instCorreoActivo");
  const instNombreList = $("instNombreList");
  const instDBInput = $("instDBInput");
  const btnLoadInstructores = $("btnLoadInstructores");

  const INST_DB = { byId: new Map(), byName: new Map(), loaded: false };

  function normKey(s){
    return (s||"").toString().trim().toLowerCase()
      .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
      .replace(/\s+/g," ");
  }

  function fillInstructorDatalist(){
    if(!instNombreList) return;
    instNombreList.innerHTML = "";

    const recs = Array.from(INST_DB.byId.values())
      .filter(rec => rec && rec.name);

    // Orden A–Z (ignorando tildes/mayúsculas)
    recs.sort((a,b) => normKey(a.name).localeCompare(normKey(b.name), "es", { sensitivity:"base" }));

    const seen = new Set();
    for(const rec of recs){
      const k = normKey(rec.name);
      if(!k) continue;
      if(seen.has(k)) continue;
      seen.add(k);
      const opt = document.createElement("option");
      opt.value = rec.name;
      instNombreList.appendChild(opt);
    }
  }

  
  async function loadInstructoresArrayBuffer(ab){
    const wb = XLSX.read(ab, { type:"array" });
    const ws = wb.Sheets[wb.SheetNames[0]];
    // raw:false ayuda a evitar notación científica en cédulas largas
    const rows = XLSX.utils.sheet_to_json(ws, { header:1, defval:"", raw:false });
    if(!rows || !rows.length) throw new Error("Base de instructores vacía.");

    const normH = (v)=> (v ?? "").toString().trim().toLowerCase()
      .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
      .replace(/[\s]+/g," ")
      .replace(/[^\w\s]/g,"");

    const cleanExcelText = (v)=>{
      let s = (v ?? "").toString().trim();
      if(!s) return "";
      s = s.replace(/\.0+$/,"");
      s = s.replace(/\s+/g," ").trim();
      return s;
    };

    const findIdx = (hdrNorm, candidates)=>{
      for(const c of candidates){
        const target = normH(c);
        const idx = hdrNorm.indexOf(target);
        if(idx >= 0) return idx;
      }
      for(let i=0;i<hdrNorm.length;i++){
        const h = hdrNorm[i];
        for(const c of candidates){
          const t = normH(c);
          if(t && h && h.includes(t)) return i;
        }
      }
      return -1;
    };

    // Buscar encabezado en primeras 10 filas
    let headerRow = 0;
    let idx = {
      id:-1,
      nombreCompleto:-1,
      nombre:-1, apellido:-1,
      pNombre:-1, sNombre:-1, pApellido:-1, sApellido:-1,
      celular:-1,
      correo:-1
    };

    const maxScan = Math.min(10, rows.length);
    for(let r=0; r<maxScan; r++){
      const hdr = (rows[r]||[]).map(v=>String(v).trim());
      const hdrNorm = hdr.map(normH);

      const idIdx = findIdx(hdrNorm, ["numero identificacion","numero_identificacion","identificacion","documento","cedula","cc"]);
      if(idIdx < 0) continue;

      const ncIdx = findIdx(hdrNorm, ["nombre completo","nombre_completo"]);
      const nIdx  = findIdx(hdrNorm, ["nombres","nombre"]);
      const aIdx  = findIdx(hdrNorm, ["apellidos","apellido"]);
      const pnIdx = findIdx(hdrNorm, ["primer nombre","1 nombre","nombre1"]);
      const snIdx = findIdx(hdrNorm, ["segundo nombre","2 nombre","nombre2"]);
      const paIdx = findIdx(hdrNorm, ["primer apellido","1 apellido","apellido1"]);
      const saIdx = findIdx(hdrNorm, ["segundo apellido","2 apellido","apellido2"]);

      const okName = (ncIdx>=0) || (nIdx>=0 && aIdx>=0) || (pnIdx>=0 && paIdx>=0);
      if(!okName) continue;

      headerRow = r;
      idx.id = idIdx;
      idx.nombreCompleto = ncIdx;
      idx.nombre = nIdx; idx.apellido = aIdx;
      idx.pNombre = pnIdx; idx.sNombre = snIdx; idx.pApellido = paIdx; idx.sApellido = saIdx;
      idx.celular = findIdx(hdrNorm, ["celular","movil","telefono","telefono movil","telefono celular"]);
      idx.correo  = findIdx(hdrNorm, ["correo","correo electronico","email","e mail"]);
      break;
    }

    // Fallback: ID, APELLIDOS, NOMBRES
    let startRow = headerRow ? (headerRow + 1) : 0;
    if(idx.id < 0){
      idx.id = 0; idx.apellido = 1; idx.nombre = 2;
      startRow = 0;
    }

    INST_DB.byId.clear();
    INST_DB.byName.clear();

    for(let i=startRow; i<rows.length; i++){
      const r = rows[i] || [];
      const id = cleanExcelText(r[idx.id]);
      if(!id) continue;

      let full = "";
      if(idx.nombreCompleto >= 0){
        full = cleanExcelText(r[idx.nombreCompleto]);
      }else if(idx.nombre >= 0 || idx.apellido >= 0){
        const nombre = cleanExcelText(r[idx.nombre]);
        const apellido = cleanExcelText(r[idx.apellido]);
        full = `${nombre} ${apellido}`.replace(/\s+/g," ").trim();
      }else{
        const pn = cleanExcelText(r[idx.pNombre]);
        const sn = cleanExcelText(r[idx.sNombre]);
        const pa = cleanExcelText(r[idx.pApellido]);
        const sa = cleanExcelText(r[idx.sApellido]);
        full = `${pn} ${sn} ${pa} ${sa}`.replace(/\s+/g," ").trim();
      }

      if(!full) continue;

      const phoneRaw = (idx.celular>=0) ? cleanExcelText(r[idx.celular]) : "";
      const emailRaw = (idx.correo>=0)  ? cleanExcelText(r[idx.correo])  : "";

      const prev = INST_DB.byId.get(id);
      const rec = prev || { id, name: full, phone:"", email:"" };

      rec.name = rec.name || full;
      if(phoneRaw && !rec.phone) rec.phone = phoneRaw;
      if(emailRaw && !rec.email) rec.email = emailRaw;

      INST_DB.byId.set(id, rec);
      INST_DB.byName.set(normKey(rec.name), rec);
    }

    INST_DB.loaded = INST_DB.byId.size > 0;
    fillInstructorDatalist();

    if(instDbStatus){
      instDbStatus.textContent = INST_DB.loaded
        ? `Base de instructores cargada: ${INST_DB.byId.size} registros.`
        : "No se encontraron instructores en la base.";
    }
    if(btnLoadInstructores) btnLoadInstructores.style.display = INST_DB.loaded ? "none" : "inline-block";
  }

  function applyInstructorRecToInputs(rec){
    if(!rec) return;
    try{ if(instCedulaEl) instCedulaEl.value = rec.id || ""; }catch(e){}
    try{ if(instNombreEl) instNombreEl.value = rec.name || instNombreEl.value; }catch(e){}
    try{ if(instCelularEl && rec.phone) instCelularEl.value = rec.phone; }catch(e){}
    try{ if(instCorreoEl && rec.email) instCorreoEl.value = rec.email; }catch(e){}
    try{
      if(instCorreoActivoEl && rec.email){
        instCorreoActivoEl.checked = /@sena\.edu\.co$/i.test(String(rec.email||"").trim());
        if(typeof updateInstructorCorreoUI === "function") updateInstructorCorreoUI();
      }
    }catch(e){}
  }

  async function tryAutoLoadInstructores(){
    // En modo archivo (file://) los navegadores bloquean fetch() por CORS.
    // Use carga manual o abra el HTML desde un servidor local (http://localhost).
    if(location.protocol === "file:"){
      if(instDbStatus) instDbStatus.textContent = "Modo archivo: cargue la base de instructores manualmente.";
      if(btnLoadInstructores) btnLoadInstructores.style.display = "inline-block";
      return;
    }
    const candidates = ["Instructores.xls","INSTRUCTORES.xls","Instructores.xlsx","INSTRUCTORES.xlsx"];
    for(const fname of candidates){
      try{
        if(instDbStatus) instDbStatus.textContent = `Buscando ${fname} en la misma carpeta...`;
        const res = await fetch(fname, { cache:"no-store" });
        if(!res.ok) throw new Error("HTTP " + res.status);
        const ab = await res.arrayBuffer();
        await loadInstructoresArrayBuffer(ab);
        return;
      }catch(e){
        // seguir intentando
      }
    }
    if(instDbStatus){
      instDbStatus.textContent = "No se pudo cargar automáticamente Instructores.xls desde la misma carpeta. Como respaldo, puede cargarla manualmente.";
      if(btnLoadInstructores) btnLoadInstructores.style.display = "inline-block";
    }
  }

  if(btnLoadInstructores && instDBInput){
    btnLoadInstructores.addEventListener("click", ()=> instDBInput.click());
    instDBInput.addEventListener("change", async (e)=>{
      const f = (e.target.files && e.target.files[0]) ? e.target.files[0] : null;
      if(!f) return;
      try{
        if(instDbStatus) instDbStatus.textContent = "Cargando base de instructores...";
        const ab = await f.arrayBuffer();
        await loadInstructoresArrayBuffer(ab);
      }catch(err){
        console.error(err);
        if(instDbStatus) instDbStatus.textContent = "No se pudo leer la base de instructores.";
      }
    });
  }

  function syncFromNombre(){
    if(!INST_DB.loaded || !instNombreEl || !instCedulaEl) return;
    const rec = INST_DB.byName.get(normKey(instNombreEl.value));
    if(rec) applyInstructorRecToInputs(rec);
  }

  function syncFromCedula(){
    if(!INST_DB.loaded || !instNombreEl || !instCedulaEl) return;
    const id = (instCedulaEl.value||"").trim();
    const rec = INST_DB.byId.get(id);
    if(rec) applyInstructorRecToInputs(rec);
  }

  if(instNombreEl){
    instNombreEl.addEventListener("input", syncFromNombre);
    instNombreEl.addEventListener("change", syncFromNombre);
    instNombreEl.addEventListener("blur", syncFromNombre);
  }
  if(instCedulaEl){
    instCedulaEl.addEventListener("change", syncFromCedula);
    instCedulaEl.addEventListener("blur", syncFromCedula);
  }

  // Auto-carga al iniciar
  setTimeout(()=>{ tryAutoLoadInstructores(); }, 120);



  firmaInput.addEventListener("change", async (e)=>{
    const f = (e.target.files && e.target.files[0]) ? e.target.files[0] : null;
    if(!f){
      STATE.instructor.firmaDataUrl = "";
      firmaPreview.style.display = "none";
      firmaPlaceholder.style.display = "block";
      return;
    }
    const dataUrl = await readFileAsDataUrl(f);
    STATE.instructor.firmaDataUrl = dataUrl;
    firmaPreview.src = dataUrl;
    firmaPreview.style.display = "block";
    firmaPlaceholder.style.display = "none";
  });

  // Navegación con TAB en overlay Instructor:
  // desde "Correo SENA" debe pasar a "Coordinador(a) Académico(a)"
  $("instCorreo").addEventListener("keydown", (e)=>{
    if(e.key === "Tab" && !e.shiftKey){
      e.preventDefault();
      $("instCoordinador").focus();
    }
  });


  function readFileAsDataUrl(file){
    return new Promise((resolve, reject)=>{
      const fr = new FileReader();
      fr.onload = () => resolve(String(fr.result || ""));
      fr.onerror = () => reject(new Error("No se pudo leer la imagen"));
      fr.readAsDataURL(file);
    });
  }

  $("btnCloseInstructor").addEventListener("click", ()=>{
    toast("Debe completar la información inicial para continuar.");
  });
  $("btnBackToFile").addEventListener("click", ()=>{
    instructorOverlay.classList.remove("show");
    fileOverlay.classList.add("show");
  });

  
  function updateInstructorCorreoUI(){
    const chk = $("instCorreoActivo");
    const lbl = $("instCorreoLabel");
    const inp = $("instCorreo");
    if(!chk || !lbl || !inp) return;
    if(chk.checked){
      lbl.textContent = "Correo SENA";
      inp.placeholder = "usuario@sena.edu.co";
    }else{
      lbl.textContent = "Correo alterno";
      inp.placeholder = "usuario@dominio.com";
    }
  }
  if($("instCorreoActivo")){
    $("instCorreoActivo").addEventListener("change", updateInstructorCorreoUI);
  }
  updateInstructorCorreoUI();

$("btnContinuar").addEventListener("click", ()=>{
    const nombre = $("instNombre").value.trim();
    const cedula = $("instCedula").value.trim();
    const celular = $("instCelular").value.trim();
    const correo = $("instCorreo").value.trim();
    const coordinador = $("instCoordinador").value.trim();
    const numCursos = Number($("instNumCursos").value || "1");

    const errs = [];
    if(!nombre) errs.push("Nombre completo es obligatorio.");
    if(!cedula) errs.push("N° cédula es obligatorio.");
    if(!celular) errs.push("Celular es obligatorio.");
    if(!correo) errs.push("Correo es obligatorio.");
    else {
      const correoActivo = $("instCorreoActivo") ? $("instCorreoActivo").checked : true;
      if(correoActivo){
        if(!/^[^@\s]+@sena\.edu\.co$/i.test(correo)) errs.push("Correo SENA debe terminar en @sena.edu.co.");
      }else{
        if(!/^[^@\s]+@[^@\s]+\.[^@\s]+$/i.test(correo)) errs.push("Correo alterno no es válido.");
      }
    }
    if(!coordinador) errs.push("Debe seleccionar coordinador(a) académico(a).");

    const noFirma = !STATE.instructor.firmaDataUrl;

    if(errs.length){
      $("instructorStatus").textContent = errs.join(" ");
      $("instructorStatus").style.color = "var(--danger)";
      return;
    }

    if(noFirma){
      $("instructorStatus").textContent = "Aviso: no cargó firma. Las fichas se generarán sin firma.";
      $("instructorStatus").style.color = "var(--warn)";
      toast("Aviso: las fichas se generarán sin firma.");
    }else{
      $("instructorStatus").textContent = "";
    }

    STATE.instructor = { nombre, cedula, celular, correo, coordinador, firmaDataUrl: STATE.instructor.firmaDataUrl };
    STATE.numCursos = clamp(numCursos, 1, 5);

    // Crear cursos
    STATE.cursos = [];
    for(let i=0; i<STATE.numCursos; i++) STATE.cursos.push(makeCurso(i));
    STATE.activeIndex = 0;

    instructorOverlay.classList.remove("show");
    initAfterInstructor();
    toast("Listo. Configure la ficha 1.");
  });

  // =========================
  // Render sidebar / main
  // =========================
  const courseSteps = $("courseSteps");
  const sidebarBadge = $("sidebarBadge");
  const instructorSummary = $("instructorSummary");
  const courseHint = $("courseHint");

  function initAfterInstructor(){
    $("emptyState").style.display = "none";
    $("courseFormWrap").style.display = "block";
    courseHint.textContent = "Seleccione una ficha para editarla. Guarde cada ficha para habilitar la generación de PDF(s).";
    renderSidebar();
    setActiveCourse(0);

    // Instructor summary
    instructorSummary.innerHTML = `
      <div style="font-weight:900;">${escapeHtml(STATE.instructor.nombre)}</div>
      <div style="margin-top:4px; color:var(--muted); font-size:12px;">
        CC ${escapeHtml(STATE.instructor.cedula)} • ${escapeHtml(STATE.instructor.celular)} • ${escapeHtml(STATE.instructor.correo)}
        <br/>Coord.: ${escapeHtml(STATE.instructor.coordinador)}
      </div>`;
  }


  const MONTHS_ES = ["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"];

  function formatMonthKeyES(key){
    // key: YYYY-MM
    const m = String(key||"").match(/^(\d{4})-(\d{2})$/);
    if(!m) return String(key||"");
    const y = Number(m[1]);
    const mm = Number(m[2]);
    const name = MONTHS_ES[Math.max(1,Math.min(12,mm))-1] || String(mm);
    return `${name} ${y}`;
  }

  function hoursByMonthForCourse(c){
    try{ ensureCourseSchedule(c); }catch(e){}
    const out = new Map();
    const entries = (c?.days?.byDate && (c.days.byDate instanceof Map)) ? Array.from(c.days.byDate.entries()) : [];
    for(const [iso,setHours] of entries){
      const dt = parseISODate(iso);
      if(!dt) continue;
      const key = `${dt.getFullYear()}-${String(dt.getMonth()+1).padStart(2,"0")}`;
      const add = (setHours && setHours.size) ? setHours.size : 0;
      out.set(key, (out.get(key)||0) + add);
    }
    return out;
  }

  function updatePdfMonthSummary(){
    const el = $("pdfMonthSummary");
    if(!el) return;

    const total = STATE.cursos.length;
    const savedCount = STATE.cursos.filter(c=>c.saved).length;
    if(!(total>0 && savedCount===total)){
      el.style.display = "none";
      el.innerHTML = "";
      return;
    }

    const parts = [];
    parts.push('<div class="pms-title">Total horas por mes (por ficha)</div>');

    // Totales generales (suma de todas las fichas)
    const grandByMonth = new Map();

    STATE.cursos.forEach((c, idx)=>{
      const byM = hoursByMonthForCourse(c);
      for(const [k,h] of byM.entries()){
        grandByMonth.set(k, (grandByMonth.get(k)||0) + (Number(h)||0));
      }

      const rows = Array.from(byM.entries()).sort((a,b)=> String(a[0]).localeCompare(String(b[0])));
      const linesHtml = rows.length
        ? rows.map(([k,h])=> `<div>${escapeHtml(formatMonthKeyES(k))}: ${Number(h)||0} h</div>`).join("")
        : `<div>0 h</div>`;

      parts.push(`
        <div class="pms-page">
          <div class="pms-line">Ficha ${idx+1}</div>
          <div class="pms-muted">${linesHtml}</div>
        </div>
      `);
    });

    const grandRows = Array.from(grandByMonth.entries()).sort((a,b)=> String(a[0]).localeCompare(String(b[0])));
    const grandLinesHtml = grandRows.length
      ? grandRows.map(([k,h])=> `<div>${escapeHtml(formatMonthKeyES(k))}: ${Number(h)||0} h</div>`).join("")
      : `<div>0 h</div>`;
    const grandTotalHours = grandRows.reduce((acc, kv)=> acc + (Number(kv[1])||0), 0);

    parts.push(`
      <div class="pms-total">
        <div class="pms-line">Total general (todas las fichas)</div>
        <div class="pms-muted">${grandLinesHtml}</div>
        <div class="pms-total-hours">Total: ${grandTotalHours} h</div>
      </div>
    `);

    el.innerHTML = parts.join("");
    el.style.display = "block";
  }


  function renderSidebar(){
    courseSteps.innerHTML = "";
    const total = STATE.cursos.length;
    const savedCount = STATE.cursos.filter(c=>c.saved).length;

    sidebarBadge.textContent = savedCount === total ? "Listo" : `${savedCount}/${total} guardadas`;
    sidebarBadge.className = "badge" + (savedCount === total ? "" : " warn");

    STATE.cursos.forEach((c, i)=>{
      const btn = document.createElement("div");
      btn.className = "step" + (i===STATE.activeIndex ? " active" : "") + (c.saved ? " saved" : "");
      btn.innerHTML = `
        <div class="num">${i+1}</div>
        <div class="meta">
          <div class="name">Curso ${i+1}</div>
          <div class="sub">${escapeHtml(c.program.name || "Sin programa")}</div>
        </div>
        <div class="state">${c.saved ? "Guardado" : "Pendiente"}</div>
      `;
      btn.addEventListener("click", ()=> setActiveCourse(i));
      courseSteps.appendChild(btn);
    });

    const allSaved = savedCount === total && total>0;
    $("btnGenerarPDFs").disabled = !allSaved;
    $("pdfHint").textContent = allSaved ? "Puede generar PDF(s)." : "Se habilita cuando todas las fichas estén guardadas.";
    updatePdfMonthSummary();
  }

  function setActiveCourse(i){
    i = clamp(Number(i)||0, 0, STATE.cursos.length-1);
    STATE.activeIndex = i;
    renderSidebar();
    renderCourseForm();
  }

  // =========================
  // Form bindings
  // =========================
  const formEls = {
    programCode: $("programCode"),
    programName: $("programName"),
    programHours: $("programHours"),
    programCodeHint: $("programCodeHint"),

    areaOcupacion: $("areaOcupacion"),
    numFichaCaracterizacion: $("numFichaCaracterizacion"),
    codigoEmpresa: $("codigoEmpresa"),

    chkEmpresa: $("chkEmpresa"),
    empresaNombre: $("empresaNombre"),
    empresaConvenio: $("empresaConvenio"),
    empresaAula: $("empresaAula"),
    empresaContacto: $("empresaContacto"),
    empresaCelular: $("empresaCelular"),
    empresaCorreo: $("empresaCorreo"),
    empresaMunicipio: $("empresaMunicipio"),
    empresaDpto: $("empresaDpto"),
    empresaDefaultsHint: $("empresaDefaultsHint"),

    empresaNombreWrap: $("empresaNombreWrap"),
    empresaConvenioWrap: $("empresaConvenioWrap"),
    empresaContactoWrap: $("empresaContactoWrap"),
    empresaCelWrap: $("empresaCelWrap"),
    empresaCorreoWrap: $("empresaCorreoWrap"),

    fechaInicioTxt: $("fechaInicioTxt"),
    fechaInicioBtn: $("fechaInicioBtn"),
    fechaInicio: $("fechaInicio"),
    fechaFinTxt: $("fechaFinTxt"),
    fechaFinBtn: $("fechaFinBtn"),
    fechaFin: $("fechaFin"),
    dowLU: $("dowLU"),
    dowMA: $("dowMA"),
    dowMI: $("dowMI"),
    dowJU: $("dowJU"),
    dowVI: $("dowVI"),
    dowSA: $("dowSA"),
    btnCalcularDias: $("btnCalcularDias"),
    chkHorario2: $("chkHorario2"),
    horario2Panel: $("horario2Panel"),
    horaInicio2: $("horaInicio2"),
    horaFin2: $("horaFin2"),
    dow2LU: $("dow2LU"),
    dow2MA: $("dow2MA"),
    dow2MI: $("dow2MI"),
    dow2JU: $("dow2JU"),
    dow2VI: $("dow2VI"),
    dow2SA: $("dow2SA"),
    calcHint: $("calcHint"),
    horaInicio: $("horaInicio"),
    horaFin: $("horaFin"),
    cupo: $("cupo"),
    cupoHint: $("cupoHint"),
    observaciones: $("observaciones"),
    obsRestricciones: $("obsRestricciones"),

    btnSeleccionarDias: $("btnSeleccionarDias"),
    diasHint: $("diasHint"),
    daysListWrap: $("daysListWrap"),
    daysTbody: $("daysTbody"),
    hoursBadge: $("hoursBadge"),
    approxDateBadge: $("approxDateBadge"),
    hoursRulesHint: $("hoursRulesHint"),
    lnkReabrirCalendario: $("lnkReabrirCalendario"),

    mainTitle: $("mainTitle"),
    mainBadge: $("mainBadge"),
    saveHint: $("saveHint"),
  };

  // Clonar opciones de horas para Horario 2 (misma lista de 1 hora)
  try{
    if(formEls.horaInicio2 && formEls.horaInicio){
      formEls.horaInicio2.innerHTML = formEls.horaInicio.innerHTML;
    }
    if(formEls.horaFin2 && formEls.horaFin){
      formEls.horaFin2.innerHTML = formEls.horaFin.innerHTML;
    }
  }catch(e){}

  
  // Fecha Inicio no puede ser anterior a hoy
  (function(){
    const minISO = todayISO();
    if(formEls.fechaInicio){
      formEls.fechaInicio.setAttribute("min", minISO);
      // si quedó con valor anterior (por ejemplo, al cargar), ajustarlo
      if(formEls.fechaInicio.value && formEls.fechaInicio.value < minISO){
        formEls.fechaInicio.value = minISO;
      }
    }
  })();


  // Sincronización de fecha (input visible DD/MM/AAAA) <-> input ISO (type=date)
  function openDatePicker(pickerEl){
    if(!pickerEl) return;
    try{
      if(typeof pickerEl.showPicker === "function") pickerEl.showPicker();
      else { pickerEl.focus(); pickerEl.click(); }
    }catch(e){
      try{ pickerEl.focus(); pickerEl.click(); }catch(_){}
    }
  }

  function setupDateField(txtEl, pickerEl, btnEl, which){
    if(!txtEl || !pickerEl) return;

    // Reglas mínimas
    if(which === "start"){
      const minISO = todayISO();
      pickerEl.setAttribute("min", minISO);
      if(pickerEl.value && pickerEl.value < minISO){
        pickerEl.value = minISO;
      }
    }

    const fromPicker = ()=>{
      txtEl.value = pickerEl.value ? fmtDMYYYY(pickerEl.value) : "";
      txtEl.classList.remove("input-invalid");
    };

    const commitFromTxt = ()=>{
      txtEl.classList.remove("input-invalid");
      const norm = normalizeDMYInput(txtEl.value);
      if(norm !== txtEl.value) txtEl.value = norm;

      if(!norm){
        pickerEl.value = "";
        const c = getActive();
        if(c) invalidateCalc(c);
        recalcSelectionAndHours(false);
        return;
      }

      const iso = parseDMYToISO(norm);
      if(!iso){
        txtEl.classList.add("input-invalid");
        try{ toast("Formato de fecha inválido. Use DD/MM/AAAA."); }catch(e){}
        fromPicker();
        return;
      }

      let finalISO = iso;
      if(which === "start"){
        const minISO = todayISO();
        if(finalISO < minISO) finalISO = minISO;
        pickerEl.setAttribute("min", minISO);
      }

      pickerEl.value = finalISO;
      fromPicker();

      // Mantener consistencia Fin >= Inicio
      if(which === "start" && formEls.fechaFin){
        formEls.fechaFin.setAttribute("min", finalISO);
        if(formEls.fechaFin.value && formEls.fechaFin.value < finalISO){
          formEls.fechaFin.value = finalISO;
          if(formEls.fechaFinTxt) formEls.fechaFinTxt.value = fmtDMYYYY(finalISO);
        }
      }

      const c2 = getActive();
      if(c2) invalidateCalc(c2);
      recalcSelectionAndHours(false);
    };

    txtEl.addEventListener("input", ()=>{
      txtEl.classList.remove("input-invalid");
      const norm = normalizeDMYInput(txtEl.value);
      if(norm !== txtEl.value) txtEl.value = norm;

      // Autocommit cuando queda completo
      if(/^\d{2}\/\d{2}\/\d{4}$/.test(txtEl.value)){
        const iso = parseDMYToISO(txtEl.value);
        if(iso){
          let finalISO = iso;
          if(which === "start"){
            const minISO = todayISO();
            if(finalISO < minISO) finalISO = minISO;
          }
          pickerEl.value = finalISO;

          if(which === "start" && formEls.fechaFin){
            formEls.fechaFin.setAttribute("min", finalISO);
            if(formEls.fechaFin.value && formEls.fechaFin.value < finalISO){
              formEls.fechaFin.value = finalISO;
              if(formEls.fechaFinTxt) formEls.fechaFinTxt.value = fmtDMYYYY(finalISO);
            }
          }

          const c3 = getActive();
          if(c3) invalidateCalc(c3);
          recalcSelectionAndHours(false);
        }
      }
    });

    txtEl.addEventListener("blur", commitFromTxt);

    pickerEl.addEventListener("change", ()=>{
      fromPicker();
      const c4 = getActive();
      if(c4) invalidateCalc(c4);

      if(which === "start" && formEls.fechaFin){
        const s = pickerEl.value || "";
        if(s) formEls.fechaFin.setAttribute("min", s);
        if(formEls.fechaFin.value && s && formEls.fechaFin.value < s){
          formEls.fechaFin.value = s;
          if(formEls.fechaFinTxt) formEls.fechaFinTxt.value = fmtDMYYYY(s);
        }
      }

      recalcSelectionAndHours(false);
    });

    if(btnEl){
      btnEl.addEventListener("click", ()=> openDatePicker(pickerEl));
    }

    fromPicker();
  }

  setupDateField(formEls.fechaInicioTxt, formEls.fechaInicio, formEls.fechaInicioBtn, "start");
  setupDateField(formEls.fechaFinTxt, formEls.fechaFin, formEls.fechaFinBtn, "end");

  // =========================
  // Días a programar (LU–SA) y botón "Calcular"
  // =========================
  
  function ensureWeekdayState(c){
    if(!c || !c.prog) return;

    // Horario principal
    if(!Array.isArray(c.prog.weekdays) || c.prog.weekdays.length === 0){
      // 1..6 => LU..SA
      c.prog.weekdays = [1,2,3,4,5,6];
    }
    if(typeof c.prog.calculated !== "boolean") c.prog.calculated = false;

    // Horario complementario (jornada mixta)
    if(!c.prog.extra || typeof c.prog.extra !== "object"){
      c.prog.extra = { enabled:false, hStart:"", hEnd:"", weekdays:[] };
    }
    if(typeof c.prog.extra.enabled !== "boolean") c.prog.extra.enabled = false;
    if(typeof c.prog.extra.hStart !== "string") c.prog.extra.hStart = "";
    if(typeof c.prog.extra.hEnd !== "string") c.prog.extra.hEnd = "";
    if(!Array.isArray(c.prog.extra.weekdays)) c.prog.extra.weekdays = [];
  }

  // Normaliza valores de día de semana: acepta 1..6, "1".."6" o abreviaturas (LU/MA/MI/JU/VI/SA)
  function normalizeDowAny(v){
    const n = Number(v);
    if([1,2,3,4,5,6].includes(n)) return n;

    const s = String(v ?? "").trim().toUpperCase();
    if(!s) return null;

    if(s==="LU" || s==="LUN" || s==="LUNES") return 1;
    if(s==="MA" || s==="MAR" || s==="MARTES") return 2;
    if(s==="MI" || s==="MIE" || s==="MIÉ" || s==="MIERCOLES" || s==="MIÉRCOLES") return 3;
    if(s==="JU" || s==="JUE" || s==="JUEVES") return 4;
    if(s==="VI" || s==="VIE" || s==="VIERNES") return 5;
    if(s==="SA" || s==="SAB" || s==="SÁB" || s==="SABADO" || s==="SÁBADO") return 6;

    return null;
  }

  function selectedDowSet1(c){
    ensureWeekdayState(c);
    const set = new Set();
    const arr = Array.isArray(c?.prog?.weekdays) && c.prog.weekdays.length ? c.prog.weekdays : [1,2,3,4,5,6];
    for(const v of arr){
      const n = normalizeDowAny(v);
      if(n) set.add(n);
    }
    return set;
  }

  function selectedDowSet2(c){
    ensureWeekdayState(c);
    const set = new Set();
    if(!c.prog.extra.enabled) return set;
    const arr = Array.isArray(c?.prog?.extra?.weekdays) ? c.prog.extra.weekdays : [];
    for(const v of arr){
      const n = normalizeDowAny(v);
      if(n) set.add(n);
    }
    return set;
  }

  // Compatibilidad: conjunto total de días programables (Horario 1 ∪ Horario 2)
  function selectedDowSet(c){
    const s = selectedDowSet1(c);
    for(const d of selectedDowSet2(c)) s.add(d);
    return s;
  }

  function weekdaysFromUI1(){
    const out = [];
    if(formEls.dowLU && formEls.dowLU.checked) out.push(1);
    if(formEls.dowMA && formEls.dowMA.checked) out.push(2);
    if(formEls.dowMI && formEls.dowMI.checked) out.push(3);
    if(formEls.dowJU && formEls.dowJU.checked) out.push(4);
    if(formEls.dowVI && formEls.dowVI.checked) out.push(5);
    if(formEls.dowSA && formEls.dowSA.checked) out.push(6);
    return out;
  }

  function weekdaysFromUI2(){
    const out = [];
    if(formEls.dow2LU && formEls.dow2LU.checked) out.push(1);
    if(formEls.dow2MA && formEls.dow2MA.checked) out.push(2);
    if(formEls.dow2MI && formEls.dow2MI.checked) out.push(3);
    if(formEls.dow2JU && formEls.dow2JU.checked) out.push(4);
    if(formEls.dow2VI && formEls.dow2VI.checked) out.push(5);
    if(formEls.dow2SA && formEls.dow2SA.checked) out.push(6);
    return out;
  }

  function syncWeekdaysUI(c){
    ensureWeekdayState(c);

    const s1 = selectedDowSet1(c);
    if(formEls.dowLU) formEls.dowLU.checked = s1.has(1);
    if(formEls.dowMA) formEls.dowMA.checked = s1.has(2);
    if(formEls.dowMI) formEls.dowMI.checked = s1.has(3);
    if(formEls.dowJU) formEls.dowJU.checked = s1.has(4);
    if(formEls.dowVI) formEls.dowVI.checked = s1.has(5);
    if(formEls.dowSA) formEls.dowSA.checked = s1.has(6);

    const ex = c.prog.extra || { enabled:false, hStart:"", hEnd:"", weekdays:[] };
    if(formEls.chkHorario2) formEls.chkHorario2.checked = !!ex.enabled;
    if(formEls.horario2Panel) formEls.horario2Panel.style.display = ex.enabled ? "block" : "none";
    if(formEls.horaInicio2) formEls.horaInicio2.value = ex.hStart || "";
    if(formEls.horaFin2) formEls.horaFin2.value = ex.hEnd || "";

    const s2 = selectedDowSet2(c);
    if(formEls.dow2LU) formEls.dow2LU.checked = s2.has(1);
    if(formEls.dow2MA) formEls.dow2MA.checked = s2.has(2);
    if(formEls.dow2MI) formEls.dow2MI.checked = s2.has(3);
    if(formEls.dow2JU) formEls.dow2JU.checked = s2.has(4);
    if(formEls.dow2VI) formEls.dow2VI.checked = s2.has(5);
    if(formEls.dow2SA) formEls.dow2SA.checked = s2.has(6);
  }

  function applyWeekdaysFromUI(c){
    ensureWeekdayState(c);

    // Horario 1
    c.prog.weekdays = weekdaysFromUI1();

    // Horario 2
    if(formEls.chkHorario2){
      c.prog.extra.enabled = !!formEls.chkHorario2.checked;
    }
    if(c.prog.extra.enabled){
      c.prog.extra.weekdays = weekdaysFromUI2();
      if(formEls.horaInicio2) c.prog.extra.hStart = formEls.horaInicio2.value || "";
      if(formEls.horaFin2) c.prog.extra.hEnd = formEls.horaFin2.value || "";
    }
  }

  function validateInternalScheduleOverlap(c){
    ensureWeekdayState(c);
    if(!c.prog.extra.enabled) return { ok:true, msg:"OK" };

    const d1 = selectedDowSet1(c);
    const d2 = selectedDowSet2(c);
    const inter = [];
    for(const d of d1){ if(d2.has(d)) inter.push(d); }
    if(!inter.length) return { ok:true, msg:"OK" };

    const m1s = minutesFromHHMM(c.prog.hStart || (formEls.horaInicio ? formEls.horaInicio.value : ""));
    const m1e = minutesFromHHMM(c.prog.hEnd   || (formEls.horaFin ? formEls.horaFin.value : ""));
    const m2s = minutesFromHHMM(c.prog.extra.hStart || (formEls.horaInicio2 ? formEls.horaInicio2.value : ""));
    const m2e = minutesFromHHMM(c.prog.extra.hEnd   || (formEls.horaFin2 ? formEls.horaFin2.value : ""));
    if(m1s===null || m1e===null || m2s===null || m2e===null) return { ok:true, msg:"OK" };

    const overlap = Math.max(m1s, m2s) < Math.min(m1e, m2e);
    if(!overlap) return { ok:true, msg:"OK" };

    const names = {1:"Lunes",2:"Martes",3:"Miércoles",4:"Jueves",5:"Viernes",6:"Sábado"};
    const dayList = inter.map(d=>names[d] || String(d)).join(", ");
    return { ok:false, msg:`El Horario Complementario se solapa con el horario principal en: ${dayList}. Ajuste horas o días.` };
  }
function invalidateCalc(c){
    if(!c || !c.prog) return;
    ensureWeekdayState(c);
    c.prog.calculated = false;
    if(formEls.daysListWrap) formEls.daysListWrap.style.display = "none";
    if(formEls.calcHint){
      formEls.calcHint.textContent = "Cambios pendientes: presione Calcular para ver el detalle.";
      formEls.calcHint.style.color = "var(--muted)";
    }
  }

  function updateCalcHint(c){
    if(!formEls.calcHint) return;
    ensureWeekdayState(c);
    if(c.prog.calculated){
      formEls.calcHint.textContent = "Detalle calculado. Revise el listado abajo.";
      formEls.calcHint.style.color = "var(--ok)";
    }else{
      formEls.calcHint.textContent = "Seleccione al menos un día (LU–SA) y presione Calcular para ver el detalle.";
      formEls.calcHint.style.color = "var(--muted)";
    }
  }




const mainTitle = $("mainTitle");
  const mainBadge = $("mainBadge");

  function renderCourseForm(){
    const c = STATE.cursos[STATE.activeIndex];
    if(!c) return;

    mainTitle.textContent = `Ficha Curso ${c.idx+1}`;
    mainBadge.textContent = c.saved ? "Guardada" : "En edición";
    mainBadge.className = "badge" + (c.saved ? "" : " warn");

    // Cargar valores
    formEls.programCode.value = c.program.code;
    formEls.programName.value = c.program.name;
    formEls.programHours.value = c.program.hours ?? "";
    formEls.programCodeHint.textContent = "";

    formEls.areaOcupacion.value = c.meta.area;
    formEls.numFichaCaracterizacion.value = c.meta.ficha;
    formEls.codigoEmpresa.value = c.meta.codigoEmpresa;

    formEls.chkEmpresa.checked = !!c.empresa.full;

    // Empresa
    formEls.empresaNombre.value = c.empresa.nombre || "";
    formEls.empresaConvenio.value = c.empresa.convenio || "";
    formEls.empresaAula.value = c.empresa.aula || "";
    formEls.empresaContacto.value = c.empresa.contacto || "";
    formEls.empresaCelular.value = c.empresa.celular || "";
    formEls.empresaCorreo.value = (c.empresa.correo || "").toLowerCase();
    formEls.empresaMunicipio.value = c.empresa.municipio || "Ibagué";
    formEls.empresaDpto.value = "Tolima";

    applyEmpresaMode();

    // Programación
    formEls.fechaInicio.value = c.prog.start || "";
    formEls.fechaFin.value = c.prog.end || "";
    
    // Predeterminar Fecha Inicio = hoy + 5 días hábiles (LU–VI), sin contar sábados ni domingos
    // Nota: el selector debe quedar habilitado desde hoy (min = hoy).
    if(formEls.fechaInicio && !formEls.fechaInicio.value){
      const minISO = todayISO();
      const defISO = addBusinessDaysISO(minISO, 5);
      formEls.fechaInicio.value = defISO;
      c.prog.start = defISO;
      formEls.fechaInicio.setAttribute("min", minISO);
    }
    // Si Fecha Finalización está vacía, predeterminarla igual a Inicio
    if(formEls.fechaInicio && formEls.fechaInicio.value && formEls.fechaFin && !formEls.fechaFin.value){
      formEls.fechaFin.value = formEls.fechaInicio.value;
      c.prog.end = formEls.fechaFin.value;
    }
    // Mantener min de Fecha Finalización según Fecha Inicio (sin bloquear escritura)
    if(formEls.fechaInicio && formEls.fechaFin && isISODateComplete(formEls.fechaInicio.value)){
      formEls.fechaFin.setAttribute("min", formEls.fechaInicio.value);
    }

    // Sincronizar inputs visibles DD/MM/AAAA
    if(formEls.fechaInicioTxt) formEls.fechaInicioTxt.value = formEls.fechaInicio.value ? fmtDMYYYY(formEls.fechaInicio.value) : "";
    if(formEls.fechaFinTxt) formEls.fechaFinTxt.value = formEls.fechaFin.value ? fmtDMYYYY(formEls.fechaFin.value) : "";

    // Días a programar (LU–SA)
    ensureWeekdayState(c);
    syncWeekdaysUI(c);
    updateCalcHint(c);

    formEls.horaInicio.value = c.prog.hStart || "";
    formEls.horaFin.value = c.prog.hEnd || "";
    formEls.cupo.value = c.prog.cupo || "";
    formEls.observaciones.value = c.prog.obs || "";

    validateCupoUI();

    // Días / horas
    recalcSelectionAndHours(false);

    updateObsRestricciones();
// hint
    formEls.saveHint.textContent = c.saved ? "Esta ficha está guardada. Puede pasar a la siguiente o generar PDF(s) cuando todas estén guardadas." : "Complete los campos obligatorios, seleccione días y guarde la ficha.";

    // botones prev/next
    $("btnPrev").disabled = (STATE.activeIndex === 0);
    $("btnNext").disabled = (STATE.activeIndex === STATE.cursos.length-1);
  }

  // -------------------------
  // Eventos: programa
  // -------------------------
  formEls.programCode.addEventListener("input", ()=>{
    const code = formEls.programCode.value.trim();
    const c = STATE.cursos[STATE.activeIndex];
    c.program.code = code;

    if(!code){
      c.program.name = "";
      c.program.hours = null;
      c.program.aMedida = "";
      formEls.programName.value = "";
      formEls.programHours.value = "";
      formEls.areaOcupacion.value = "";
      formEls.programCodeHint.textContent = "Ingrese un código para buscar en el catálogo.";
      formEls.programCodeHint.style.color = "var(--muted)";
      updateObsRestricciones();
      return;
    }

    const found = STATE.catalogMap.get(code);
    if(found){
      c.program.name = found.name;
      c.program.hours = Number(found.hours);
      c.program.aMedida = String(found.aMedida || "");
      formEls.programName.value = found.name;
      formEls.programHours.value = Number(found.hours);


      c.meta.area = (found.area || "").trim();
      formEls.areaOcupacion.value = c.meta.area;
      formEls.programCodeHint.textContent = "Código encontrado.";
      formEls.programCodeHint.style.color = "var(--ok)";
      // Recalcular horas si ya hay programación
      recalcSelectionAndHours(false);
      updateObsRestricciones();
    }else{
      c.program.name = "";
      c.program.hours = null;
      c.program.aMedida = "";
      formEls.programName.value = "";
      formEls.programHours.value = "";
      formEls.areaOcupacion.value = "";
      formEls.programCodeHint.textContent = "Código NO encontrado en el catálogo.";
      formEls.programCodeHint.style.color = "var(--danger)";
      updateObsRestricciones();
    }
  });

  // -------------------------
  // Eventos: meta
  // -------------------------
  // Área Ocupación se calcula automáticamente desde el catálogo (columna F)
  formEls.numFichaCaracterizacion.addEventListener("input", ()=>{
    STATE.cursos[STATE.activeIndex].meta.ficha = formEls.numFichaCaracterizacion.value.trim();
  });
  formEls.codigoEmpresa.addEventListener("input", ()=>{
    STATE.cursos[STATE.activeIndex].meta.codigoEmpresa = formEls.codigoEmpresa.value.trim();
  });

  // -------------------------
  // Empresa
  // -------------------------
  formEls.chkEmpresa.addEventListener("change", ()=>{
    const c = STATE.cursos[STATE.activeIndex];
    c.empresa.full = formEls.chkEmpresa.checked;
    applyEmpresaMode();
  });

  function applyEmpresaMode(){
    const c = STATE.cursos[STATE.activeIndex];
    const full = !!formEls.chkEmpresa.checked;

    // Mostrar/ocultar campos
    formEls.empresaNombreWrap.style.display = full ? "block" : "none";
    formEls.empresaConvenioWrap.style.display = full ? "block" : "none";
    formEls.empresaContactoWrap.style.display = full ? "block" : "none";
    formEls.empresaCelWrap.style.display = full ? "block" : "none";
    formEls.empresaCorreoWrap.style.display = full ? "block" : "none";

    if(!full){
      // aplicar defaults
      c.empresa.nombre = EMPRESA_DEFAULTS.nombre;
      c.empresa.convenio = EMPRESA_DEFAULTS.convenio;
      c.empresa.contacto = EMPRESA_DEFAULTS.contacto;
      c.empresa.celular = EMPRESA_DEFAULTS.celular;
      c.empresa.correo = EMPRESA_DEFAULTS.correo;

      formEls.empresaNombre.value = c.empresa.nombre;
      formEls.empresaConvenio.value = c.empresa.convenio;
      formEls.empresaContacto.value = c.empresa.contacto;
      formEls.empresaCelular.value = c.empresa.celular;
      formEls.empresaCorreo.value = c.empresa.correo;

      formEls.empresaDefaultsHint.innerHTML =
        `Valores predeterminados aplicados: <strong>Nombre empresa</strong>=${EMPRESA_DEFAULTS.nombre}, <strong>Convenio</strong>=${EMPRESA_DEFAULTS.convenio}, <strong>Contacto/Celular/Correo</strong>=NO APLICA.`;
      formEls.empresaDefaultsHint.style.color = "var(--muted)";
    }else{
      formEls.empresaDefaultsHint.textContent = "Modo empresa activado: diligencie los campos visibles.";
      formEls.empresaDefaultsHint.style.color = "var(--muted)";
    }

    // Bind inputs (siempre actualiza estado)
    c.empresa.aula = formEls.empresaAula.value.trim();
    c.empresa.municipio = formEls.empresaMunicipio.value || "Ibagué";
  }

  ;[formEls.empresaNombre, formEls.empresaConvenio, formEls.empresaAula, formEls.empresaContacto, formEls.empresaCelular, formEls.empresaCorreo].forEach(el=>{
    el.addEventListener("input", ()=>{
      const c = STATE.cursos[STATE.activeIndex];
      c.empresa.nombre = formEls.empresaNombre.value.trim();
      c.empresa.convenio = formEls.empresaConvenio.value.trim();
      c.empresa.aula = formEls.empresaAula.value.trim();
      c.empresa.contacto = formEls.empresaContacto.value.trim();
      c.empresa.celular = formEls.empresaCelular.value.trim();
      c.empresa.correo = formEls.empresaCorreo.value.trim();
    });
  });
  formEls.empresaMunicipio.addEventListener("change", ()=>{
    STATE.cursos[STATE.activeIndex].empresa.municipio = formEls.empresaMunicipio.value || "Ibagué";
  });

  // -------------------------
  // Programación inputs
  // -------------------------
  // Actualiza .list-days en tiempo real al completar/editar Fecha Inicio, Fecha Finalización, Hora Inicio y Hora Fin
  const _scheduleRecalc = (()=>{
    let t = null;
    return (immediate=false)=>{
      if(t){ clearTimeout(t); t=null; }
      if(immediate){
        recalcSelectionAndHours(false);
        updateObsRestricciones();
        return;
      }
      t = setTimeout(()=>{
        recalcSelectionAndHours(false);
        updateObsRestricciones();
      }, 80);
    };
  })();

  ;[formEls.fechaInicio, formEls.fechaFin, formEls.horaInicio, formEls.horaFin, formEls.horaInicio2, formEls.horaFin2, formEls.chkHorario2].filter(Boolean).forEach(el=>{
    const handler = (evt)=>{
      normalizeHoraInputs();

      // Validación (suave): solo cuando la fecha está completa (YYYY-MM-DD)
      if(formEls.fechaInicio){
        const v = formEls.fechaInicio.value;
        if(isISODateComplete(v)){
          const minISO = formEls.fechaInicio.getAttribute("min") || todayISO();
          if(isISODateComplete(minISO) && v < minISO){
            formEls.fechaInicio.value = minISO;
            if(formEls.fechaInicioTxt) formEls.fechaInicioTxt.value = fmtDMYYYY(minISO);
            toast("Fecha Inicio no puede ser anterior a hoy.");
          }
        }
      }

      // Mantener Fecha Finalización >= Fecha Inicio (solo cuando ambas fechas están completas)
      if(formEls.fechaInicio && formEls.fechaFin){
        const sVal = formEls.fechaInicio.value;
        if(isISODateComplete(sVal)) formEls.fechaFin.setAttribute("min", sVal);

        const eVal = formEls.fechaFin.value;
        if(isISODateComplete(eVal) && isISODateComplete(sVal) && eVal < sVal){
          formEls.fechaFin.value = sVal; if(formEls.fechaFinTxt) formEls.fechaFinTxt.value = fmtDMYYYY(sVal);
          toast("Fecha Finalización debe ser mayor o igual a Fecha Inicio.");
        }
      }

      const c = STATE.cursos[STATE.activeIndex];
      invalidateCalc(c);
      c.prog.start = formEls.fechaInicio.value;
      c.prog.end = formEls.fechaFin.value;
      c.prog.hStart = formEls.horaInicio.value;
      c.prog.hEnd = formEls.horaFin.value;

      const allFilled = !!(formEls.fechaInicio.value && formEls.fechaFin.value && formEls.horaInicio.value && formEls.horaFin.value);

      // En el primer ingreso de Hora Fin, recalcular apenas el valor esté completo (HH:MM)
      if(evt.type==="input"){
        if(el === formEls.horaFin && /^\d{2}:\d{2}$/.test(formEls.horaFin.value) && allFilled){
          _scheduleRecalc(true);
        }else{
          _scheduleRecalc(false);
        }
        return;
      }

      // change/blur: recalcular inmediato
      _scheduleRecalc(true);
    };

    el.addEventListener("input", handler);
    el.addEventListener("change", handler);
    el.addEventListener("blur", handler);
  });


  // -------------------------
  // Días a programar (LU–SA) + Calcular
  // -------------------------
  (function(){
    const binds = [formEls.dowLU, formEls.dowMA, formEls.dowMI, formEls.dowJU, formEls.dowVI, formEls.dowSA, formEls.chkHorario2, formEls.dow2LU, formEls.dow2MA, formEls.dow2MI, formEls.dow2JU, formEls.dow2VI, formEls.dow2SA].filter(Boolean);
    binds.forEach(cb=>{
      cb.addEventListener("change", ()=>{
        const c = getActive();
        if(!c) return;
        applyWeekdaysFromUI(c);
        syncWeekdaysUI(c);
        invalidateCalc(c);
        // recalcular selección base (sin mostrar detalle hasta presionar Calcular)
        recalcSelectionAndHours(false);
        updateObsRestricciones();
        if(calendarModal && calendarModal.classList.contains("show")){
          try{ renderCalendar(); }catch(e){}
        }
      });
    });

    if(formEls.btnCalcularDias){
      formEls.btnCalcularDias.addEventListener("click", ()=>{
        const c = getActive();
        if(!c) return;

        applyWeekdaysFromUI(c);

        if(selectedDowSet(c).size === 0){
          toast("Seleccione al menos un día (LU–SA) para programar.");
          return;
        }

        const pr = validatePrereqsForDayList();
        if(!pr.ok){
          toast(pr.msg);
          formEls.diasHint.textContent = pr.msg;
          formEls.diasHint.style.color = "var(--danger)";
          return;
        }

        c.prog.calculated = true;
        updateCalcHint(c);
        recalcSelectionAndHours(false);

        formEls.diasHint.textContent = "Detalle calculado. Revise el listado abajo.";
        formEls.diasHint.style.color = "var(--ok)";
      });
    }
  })();


formEls.cupo.addEventListener("input", ()=>{
    STATE.cursos[STATE.activeIndex].prog.cupo = formEls.cupo.value;
    validateCupoUI();
    updateObsRestricciones();
  });

  function validateCupoUI(){
    const cupo = Number(formEls.cupo.value || 0);
    if(!cupo || cupo < 1){
      formEls.cupo.style.borderColor = "var(--border-strong)";
      formEls.cupoHint.textContent = "";
      return;
    }
    if(cupo < 30){
      formEls.cupo.style.borderColor = "rgba(185,28,28,.65)";
      formEls.cupoHint.textContent = "Cupo menor a 30: recuerde que el mínimo son 30 aprendices (queda en rojo).";
      formEls.cupoHint.style.color = "var(--danger)";
    }else{
      formEls.cupo.style.borderColor = "rgba(57,169,0,.55)";
      formEls.cupoHint.textContent = "Cupo válido.";
      formEls.cupoHint.style.color = "var(--ok)";
    }
  }

  function countBusinessDaysFromTomorrowTo(startISO){
    const start = parseISODate(startISO);
    if(!start) return 0;
    start.setHours(0,0,0,0);

    const today = new Date();
    today.setHours(0,0,0,0);

    let d = new Date(today);
    d.setDate(d.getDate()+1);

    let count = 0;
    while(d <= start){
      const dow = d.getDay(); // 0=domingo ... 6=sábado
      if(dow >= 1 && dow <= 5) count++;
      d.setDate(d.getDate()+1);
    }
    return count;
  }

  function updateObsRestricciones(){
    const c = STATE.cursos[STATE.activeIndex];
    if(!c || !formEls.obsRestricciones) return;

    const red = [];
    const yellow = [];

    // Condición 1: mínimo 5 días hábiles (lunes a viernes) antes de la fecha de inicio
    const fIni = formEls.fechaInicio.value || c.prog.start;
    if(fIni){
      const bd = countBusinessDaysFromTomorrowTo(fIni);
      if(bd < 5){
        red.push("La ficha se está solicitando con menos de 5 días hábiles.");
      }
    }

    // Condición 2: cupo mínimo 30 (no bloquea, solo registra)
    const cupoV = Number((formEls.cupo.value || c.prog.cupo) || 0);
    if(cupoV && cupoV < 30){
      red.push(`El cupo de esta ficha se está solicitando con ${cupoV} aprendices; recuerde que el mínimo son 30 aprendices.`);
    }

    // Condición 3: duración > 60 horas
    const durProg = Number(c.program.hours || 0);
    if(durProg && durProg > 60){
      red.push("La duración de este curso supera las 60 horas, en las cuales el instructor podrá solicitar apertura.");
    }

    // Condición 4: A la medida = SI (desde catálogo)
    const aMed = String(c.program.aMedida || "").trim().toUpperCase();
    if(aMed === "SI"){
      red.push("Este curso que se solicita es a la medida.");
    }

    // Advertencia (amarillo): se permite crear/guardar con menos horas programadas (no bloquea)
    const totalH = Number((c.computed && c.computed.totalHours) || 0);
    if(durProg && totalH && totalH < durProg){
      yellow.push(`El curso se programará con menos horas: ${totalH} de ${durProg} (Duración).`);
    }

    // Render: numeración continua 1..n (amarillo siempre al final)
    const all = [];
    red.forEach(t => all.push({ text:t, cls:"" }));
    yellow.forEach(t => all.push({ text:t, cls:"obs-yellow" }));

    formEls.obsRestricciones.innerHTML = all.map(obj => `<li class="${obj.cls}">${escapeHtml(obj.text)}</li>`).join("");
    formEls.obsRestricciones.style.display = all.length ? "block" : "none";

    // Mantener por compatibilidad, pero oculto (todo va numerado en obsRestricciones)
    if(formEls.obsAdvertencias){
      formEls.obsAdvertencias.innerHTML = "";
      formEls.obsAdvertencias.style.display = "none";
    }
  }




  formEls.observaciones.addEventListener("input", ()=>{
    STATE.cursos[STATE.activeIndex].prog.obs = formEls.observaciones.value.trim();
  });

  // =========================
  // Calendario: abrir / render
  // =========================
  formEls.btnSeleccionarDias.addEventListener("click", ()=> openCalendarModal());
  formEls.lnkReabrirCalendario.addEventListener("click", (e)=>{ e.preventDefault(); openCalendarModal(); });

  $("btnCloseCalendar").addEventListener("click", ()=> calendarModal.classList.remove("show"));
  $("btnSelectAll").addEventListener("click", ()=>{ const c=getActive(); if(!c) return; c.days.excluded = new Set(); renderCalendar(); });
  $("btnClearAll").addEventListener("click", ()=>{ const c=getActive(); if(!c) return; // excluir todo: marcar todos los hábiles como excluidos
    const base = computeBaseSelectableDays(c).baseSelectable;
    c.days.excluded = new Set(base);
    renderCalendar();
  });
  $("btnGuardarDias").addEventListener("click", ()=>{
    calendarModal.classList.remove("show");
    recalcSelectionAndHours(true);
    toast("Días guardados.");
  });

  function getActive(){ return STATE.cursos[STATE.activeIndex]; }

  function openCalendarModal(){
    const c = getActive();
    const v = validatePrereqsForCalendar(c);
    if(!v.ok){
      toast(v.msg);
      formEls.diasHint.textContent = v.msg;
      formEls.diasHint.style.color = "var(--danger)";
      return;
    }
    formEls.diasHint.textContent = "Calendario listo.";
    formEls.diasHint.style.color = "var(--ok)";

    $("calTitle").textContent = `Seleccionar días • Curso ${c.idx+1}`;
    calendarModal.classList.add("show");
    renderCalendar();
  }

  function validatePrereqsForCalendar(c){

    normalizeHoraInputs();
    ensureWeekdayState(c);

    // Días
    if(selectedDowSet(c).size === 0) return { ok:false, msg:"Seleccione al menos un día (LU–SA) para programar." };

    // Programa
    if(!c.program.code || !c.program.name || !c.program.hours) return { ok:false, msg:"Ingrese un Código de Programa válido (debe existir en el catálogo)." };

    // Fechas
    const s = parseISODate(formEls.fechaInicio.value);
    const e = parseISODate(formEls.fechaFin.value);
    if(!s || !e) return { ok:false, msg:"Defina Fecha Inicio y Fecha Finalización." };
    const minISO = formEls.fechaInicio.getAttribute("min") || todayISO();
    if(formEls.fechaInicio.value && formEls.fechaInicio.value < minISO) return { ok:false, msg:"Fecha Inicio no puede ser anterior a hoy." };
    if(e < s) return { ok:false, msg:"Rango inválido: Fecha Finalización debe ser mayor o igual a Fecha Inicio." };

    // Horario 1
    const m1 = minutesFromHHMM(formEls.horaInicio.value);
    const m2 = minutesFromHHMM(formEls.horaFin.value);
    if(m1 === null || m2 === null || m2 <= m1) return { ok:false, msg:"Defina Hora Inicio y Hora Fin válidas." };
    if((m1 % 60) !== 0 || (m2 % 60) !== 0) return { ok:false, msg:"Para cumplir la regla, use minutos en 00 (bloques de 1 hora)." };

    // Horario 2 (si está activo)
    if(c.prog.extra && c.prog.extra.enabled){
      if(selectedDowSet2(c).size === 0) return { ok:false, msg:"Seleccione al menos un día en el Horario Complementario (Días 2)." };

      const m3 = minutesFromHHMM(formEls.horaInicio2 ? formEls.horaInicio2.value : "");
      const m4 = minutesFromHHMM(formEls.horaFin2 ? formEls.horaFin2.value : "");
      if(m3 === null || m4 === null || m4 <= m3) return { ok:false, msg:"Defina Hora Inicio 2 y Hora Fin 2 válidas." };
      if((m3 % 60) !== 0 || (m4 % 60) !== 0) return { ok:false, msg:"Para cumplir la regla, use minutos en 00 (bloques de 1 hora) en Horario 2." };

      const ov = validateInternalScheduleOverlap(c);
      if(!ov.ok) return { ok:false, msg: ov.msg };
    }

    return { ok:true, msg:"OK" };
  }

  // Validación para recalcular/mostrar la lista de días (no exige programa; solo fechas y horas)
  function validatePrereqsForDayList(){
    const c = getActive();
    if(c){
      normalizeHoraInputs();
      ensureWeekdayState(c);
      if(selectedDowSet(c).size === 0) return { ok:false, msg:"Seleccione al menos un día (LU–SA) para programar." };

      // Si horario 2 está activo, validar datos mínimos y cruce interno
      if(c.prog.extra && c.prog.extra.enabled){
        if(selectedDowSet2(c).size === 0) return { ok:false, msg:"Seleccione al menos un día en el Horario Complementario (Días 2)." };

        const m3 = minutesFromHHMM(formEls.horaInicio2 ? formEls.horaInicio2.value : "");
        const m4 = minutesFromHHMM(formEls.horaFin2 ? formEls.horaFin2.value : "");
        if(m3 === null || m4 === null || m4 <= m3) return { ok:false, msg:"Defina Hora Inicio 2 y Hora Fin 2 válidas." };
        if((m3 % 60) !== 0 || (m4 % 60) !== 0) return { ok:false, msg:"Para cumplir la regla, use minutos en 00 (bloques de 1 hora) en Horario 2." };

        const ov = validateInternalScheduleOverlap(c);
        if(!ov.ok) return { ok:false, msg: ov.msg };
      }
    }

    const s = parseISODate(formEls.fechaInicio.value);
    const e = parseISODate(formEls.fechaFin.value);
    if(!s || !e) return { ok:false, msg:"Defina Fecha Inicio y Fecha Finalización." };
    if(e < s) return { ok:false, msg:"Rango inválido: Fecha Finalización debe ser mayor o igual a Fecha Inicio." };

    const m1 = minutesFromHHMM(formEls.horaInicio.value);
    const m2 = minutesFromHHMM(formEls.horaFin.value);
    if(m1 === null || m2 === null || m2 <= m1) return { ok:false, msg:"Defina Hora Inicio y Hora Fin válidas." };
    if((m1 % 60) !== 0 || (m2 % 60) !== 0) return { ok:false, msg:"Para cumplir la regla, use minutos en 00 (bloques de 1 hora)." };

    return { ok:true, msg:"OK" };
  }


  // Construye el conjunto de días hábiles seleccionables en el rango (excluye domingos/festivos)
  function computeBaseSelectableDays(c){
    const start = parseISODate(c.prog.start || formEls.fechaInicio.value);
    const end = parseISODate(c.prog.end || formEls.fechaFin.value);
    if(!start || !end) return { baseSelectable: [], nonWork: 0 };
    const dates = datesBetweenInclusive(start, end);
    const baseSelectable = [];
    const allowedDows = selectedDowSet(c);
    let nonWork = 0;
    for(const d of dates){
      const iso = formatISO(d.getFullYear(), d.getMonth()+1, d.getDate());
      const dow = d.getDay(); // 0 domingo
      const isHoliday = (d.getFullYear() === 2026) && FESTIVOS_2026.has(iso);
      if(dow === 0 || isHoliday){
        nonWork++;
        continue;
      }
      if(!allowedDows.has(dow)) continue;
      baseSelectable.push(iso); // lunes-sábado no festivo
    }
    return { baseSelectable, nonWork };
  }

  function isBusyForThisCourse(c, iso){
  // Día ocupado si al menos una hora del rango está asignada a otra ficha
  const allowed = (typeof allowedHoursFromCourse === "function") ? allowedHoursFromCourse(c) : [];
  if(!allowed || !allowed.length) return null;
  for(const h of allowed){
    const e = (typeof isHourBusy === "function") ? isHourBusy(iso, h, c.idx) : null;
    if(e) return e;
  }
  return null;
}

  function renderCalendarLegacy(){
    const c = getActive();
    if(!c) return;

    // preparar datos
    const { baseSelectable, nonWork } = computeBaseSelectableDays(c);

    // Contar busy para badge
    let busyCount = 0;
    for(const iso of baseSelectable){
      if(isBusyForThisCourse(c, iso)) busyCount++;
    }
    c.computed.nonWorkCount = nonWork;
    c.computed.busyCount = busyCount;

    $("calRangeBadge").textContent = `${toDDMMYYYY(c.prog.start || formEls.fechaInicio.value)} → ${toDDMMYYYY(c.prog.end || formEls.fechaFin.value)} • ${hhmmFromMinutes(minutesFromHHMM(c.prog.hStart || formEls.horaInicio.value))}–${displayEndMinusOneMinute(c.prog.hEnd || formEls.horaFin.value)}`;
    $("calBusyBadge").style.display = busyCount ? "inline-flex" : "none";
    $("calHint").innerHTML = busyCount
      ? `Hay <strong>${busyCount}</strong> día(s) ocupados para este mismo horario (por otras fichas). Esos días quedan bloqueados hasta que cambie el horario o la fecha.`
      : `No hay conflictos de horario con otras fichas para este rango.`;

    // Render mini calendars por mes (similar al proyecto de calendario)
    const start = parseISODate(c.prog.start);
    const end = parseISODate(c.prog.end);

    const monthCursor = new Date(start.getFullYear(), start.getMonth(), 1);
    const monthEnd = new Date(end.getFullYear(), end.getMonth(), 1);

    const wrap = $("miniWrap");
    wrap.innerHTML = "";

    while(monthCursor <= monthEnd){
      const y = monthCursor.getFullYear();
      const m = monthCursor.getMonth();

      const card = document.createElement("div");
      card.className = "mini-month";

      const title = document.createElement("div");
      title.className = "mini-month-title";
      title.textContent = (MONTH_NAMES[m] || "").toUpperCase() + " " + y;
      card.appendChild(title);

      const grid = document.createElement("div");
      grid.className = "mini-grid";

      DOWS.forEach(d=>{
        const el = document.createElement("div");
        el.className = "mini-dow";
        el.textContent = d;
        grid.appendChild(el);
      });

      const firstDow = new Date(y, m, 1).getDay();
      const daysInMonth = new Date(y, m+1, 0).getDate();

      const cells = [];
      for(let i=0;i<firstDow;i++) cells.push(null);
      for(let d=1; d<=daysInMonth; d++){
        const date = new Date(y,m,d);
        date.setHours(0,0,0,0);
        const iso = formatISO(y, m+1, d);

        const inRange = (date >= start && date <= end);
        const dow = date.getDay();
        const isHoliday = (y === 2026) && FESTIVOS_2026.has(iso);
        const nonWork = inRange && (dow===0 || isHoliday);
        const baseWorkDay = inRange && !nonWork;

        const busy = baseWorkDay ? isBusyForThisCourse(c, iso) : null;
        const excluded = baseWorkDay && c.days.excluded.has(iso);
        const selected = baseWorkDay && !c.days.excluded.has(iso);

        cells.push({ d, iso, inRange, nonWork, baseWorkDay, selected, excluded, busy });
      }
      while(cells.length % 7 !== 0) cells.push(null);

      cells.forEach((cell, idx)=>{
        const el = document.createElement("div");
        el.className = "mini-day";
        if(!cell){
          el.classList.add("empty");
          el.textContent = "0";
          grid.appendChild(el);
          return;
        }
        el.textContent = String(cell.d);
        if(cell.inRange) el.classList.add("inrange");
        if(cell.nonWork) el.classList.add("nonwork");
        if(cell.busy) el.classList.add("busy");
        else if(cell.selected) el.classList.add("selected");
        else if(cell.excluded) el.classList.add("excluded");

        // conexión visual (solo seleccionados)
        if(cell.selected){
          const isFirstInWeek = (idx % 7 === 0);
          const isLastInWeek = (idx % 7 === 6);
          const left = !isFirstInWeek ? cells[idx-1] : null;
          const right = !isLastInWeek ? cells[idx+1] : null;
          const leftSel = left && left.selected;
          const rightSel = right && right.selected;
          if(leftSel && rightSel) el.classList.add("sel-mid");
          else if(leftSel) el.classList.add("sel-right");
          else if(rightSel) el.classList.add("sel-left");
        }

        if(cell.baseWorkDay && !cell.busy){
          el.title = "Clic para excluir/restaurar el día";
          el.style.cursor = "pointer";
          el.addEventListener("click", ()=>{
            if(c.days.excluded.has(cell.iso)) c.days.excluded.delete(cell.iso);
            else c.days.excluded.add(cell.iso);
            renderCalendar();
          });
        }else if(cell.busy){
          el.title = `Ocupado por: ${cell.busy.label}`;
        }else if(cell.nonWork){
          el.title = "Domingo o festivo: no programable";
        }

        grid.appendChild(el);
      });

      card.appendChild(grid);
      wrap.appendChild(card);

      monthCursor.setMonth(monthCursor.getMonth()+1);
    }

    // Previsualizar horas
    const preview = computeSelectionAndHours(c);
    $("calHoursPreview").textContent = `${preview.totalHours} horas • ${preview.selected.length} día(s) • ${preview.hoursPerDay} h/día`;
  }

  function displayEndMinusOneMinute(hhmm){
    // Para mostrar 11:59 cuando el usuario eligió 12:00 (bloques por hora).
    const min = minutesFromHHMM(hhmm);
    if(min === null) return hhmm || "";
    const show = min - 1;
    return hhmmFromMinutes(show < 0 ? 0 : show);
  }

  // =========================
  // Días + horas: cálculo y render
  // =========================
  function computeSelectionAndHours(c){
    ensureCourseSchedule(c);

    // Fallback (legacy): rango base - excluidos
    const { baseSelectable } = computeBaseSelectableDays(c);

    const baseSet = new Set(baseSelectable);
    // Limpiar entradas fuera de rango o excluidas (evita filas "fantasma" al cambiar días/fechas)
    if(c.days.byDate && (c.days.byDate instanceof Map) && c.days.byDate.size){
      for(const iso0 of Array.from(c.days.byDate.keys())){
        if(!baseSet.has(iso0) || c.days.excluded.has(iso0)){
          c.days.byDate.delete(iso0);
        }
      }
    }

    const selected = baseSelectable.filter(iso => !c.days.excluded.has(iso)).sort();
    c.days.selected = selected;

    const startMin = minutesFromHHMM(c.prog.hStart);
    const endMin = minutesFromHHMM(c.prog.hEnd);
    const hoursPerDay = (startMin===null || endMin===null) ? 0 : (endMin - startMin) / 60;

    const totalHours = Math.round((selected.length * hoursPerDay) * 100) / 100;

    c.computed.hoursPerDay = hoursPerDay;
    c.computed.totalHours = totalHours;

    return { selected, hoursPerDay, totalHours };
  }

  
  function syncFechaFinToLastSelected(c){
    try{ ensureCourseSchedule(c); }catch(e){}
    const keys = (c?.days?.byDate && (c.days.byDate instanceof Map) && c.days.byDate.size)
      ? Array.from(c.days.byDate.keys()).sort()
      : (Array.isArray(c?.days?.selected) ? c.days.selected.slice().sort() : []);

    if(!keys.length) return;
    const last = keys[keys.length - 1];

    const cur = (formEls?.fechaFin?.value || c?.prog?.end || "");
    // No sobrescribir mientras el usuario está escribiendo en el campo visible
    if(formEls?.fechaFinTxt && document.activeElement === formEls.fechaFinTxt) return;
    // Solo "encoger" cuando el valor actual supera el último día seleccionado
    if(cur && isISODateComplete(cur) && cur <= last) return;

    if(formEls?.fechaFin) formEls.fechaFin.value = last;
    if(formEls?.fechaFinTxt) formEls.fechaFinTxt.value = fmtDMYYYY(last);
    if(c?.prog) c.prog.end = last;
    if(formEls?.fechaInicio?.value) formEls.fechaFin.setAttribute("min", formEls.fechaInicio.value);
  }

function recalcSelectionAndHours(fromCalendar){
    const c = getActive();
    if(!c) return;

    // actualizar del UI (Horario 1)
    c.prog.start = formEls.fechaInicio.value;
    c.prog.end = formEls.fechaFin.value;
    c.prog.hStart = formEls.horaInicio.value;
    c.prog.hEnd = formEls.horaFin.value;

    ensureWeekdayState(c);
    try{ applyWeekdaysFromUI(c); }catch(e){}

    ensureCourseSchedule(c);

    const ov = validateInternalScheduleOverlap(c);
    const ignoreExtra = (!ov.ok);

    const { baseSelectable } = computeBaseSelectableDays(c);
    const baseSet = new Set(baseSelectable);

    // conservar excluidos que sigan en rango
    c.days.excluded = new Set(Array.from(c.days.excluded).filter(iso => baseSet.has(iso)));

    // recomputar días completamente ocupados (derivado)
    c.days.blocked = new Set();

    // Quitar entradas fuera de rango/excluidas
    for(const iso of Array.from(c.days.byDate.keys())){
      if(!baseSet.has(iso) || c.days.excluded.has(iso)) c.days.byDate.delete(iso);
    }

    // Crear/ajustar entradas por defecto para días seleccionados (no excluidos)
    for(const iso of baseSelectable){
      if(c.days.excluded.has(iso)) continue;

      const allowedIso = allowedHoursFromCourse(c, iso, { ignoreExtra });
      if(!allowedIso || !allowedIso.length){
        // en este día no hay horario aplicable
        c.days.byDate.delete(iso);
        continue;
      }

      if(!c.days.byDate.has(iso)){
        const set = new Set();
        for(const h of allowedIso){
          if(!isHourBusyPrior(iso, h, c.idx)) set.add(h);
        }
        if(set.size){
          c.days.byDate.set(iso, set);
        }else{
          // sin horas disponibles -> bloqueado por ficha(s) anterior(es)
          c.days.blocked.add(iso);
        }
      }else{
        // Si el usuario no ha personalizado horas en el calendario, mantener sincronizado con Hora Inicio/Fin.
        if(c.days.autoHours){
          const set = new Set();
          for(const h of allowedIso){
            if(!isHourBusyPrior(iso, h, c.idx)) set.add(h);
          }
          if(set.size){
            c.days.byDate.set(iso, set);
          }else{
            c.days.byDate.delete(iso);
            c.days.blocked.add(iso);
          }
        }else{
          // recortar a horas permitidas, y quitar ocupadas
          const set = c.days.byDate.get(iso);
          for(const h of Array.from(set)){
            if(!allowedIso.includes(h) || isHourBusy(iso, h, c.idx)) set.delete(h);
          }
          if(set.size===0){
            c.days.byDate.delete(iso);
            c.days.blocked.add(iso);
          }
        }
      }
    }

    // set activeISO
    const keys = Array.from(c.days.byDate.keys()).sort();
    if(!c.days.activeISO || !c.days.byDate.has(c.days.activeISO)){
      c.days.activeISO = keys.length ? keys[0] : null;
    }

    computeSelectionAndHours(c);
    renderDaysList();

    // Aviso: cuando existan cruces parciales, se programa solo en las horas disponibles (naranja)
    try{
      if(!fromCalendar){
        let n = 0;
        for(const iso of c.days.byDate.keys()){
          const st = dayStatusForCourse(c, iso);
          if(st.partialBusy && !c.days.partialNotified.has(iso)){
            c.days.partialNotified.add(iso);
            n++;
          }
        }
        if(n>0){
          toast(`Se ajustó la programación: ${n} día(s) tenían cruces y se programaron solo en las horas disponibles (marcadas en naranja).`);
        }
      }
    }catch(e){}

    // Mostrar error de solape interno (si aplica) sin romper UI
    if(!ov.ok && formEls.calcHint){
      formEls.calcHint.textContent = ov.msg;
      try{ formEls.calcHint.style.color = "#b91c1c"; }catch(e){}
    }else if(formEls.calcHint){
      try{ formEls.calcHint.style.color = ""; }catch(e){}
    }
  }

  function renderDaysList(){
    const c = getActive();
    if(!c) return;

    const pr = validatePrereqsForDayList();
    ensureWeekdayState(c);
    const canShow = pr.ok && c.days.selected && c.days.selected.length > 0 && !!c.prog.calculated;

    if(!canShow){
      formEls.daysListWrap.style.display = "none";
      return;
    }

    formEls.daysListWrap.style.display = "block";
    formEls.daysTbody.innerHTML = "";

    const { selected, hoursPerDay, totalHours } = computeSelectionAndHours(c);

    // badge horas vs programa
    const progHours = Number(c.program.hours || 0);
    formEls.hoursBadge.textContent = `${totalHours} / ${progHours} horas`;

    

    if(formEls.approxDateBadge){
      formEls.approxDateBadge.style.display = "none";
      formEls.approxDateBadge.dataset.iso = "";
      formEls.approxDateBadge.textContent = "";
    }
let badgeClass = "badge";
    let rules = [];
    if(!progHours){
      badgeClass = "badge warn";
      rules.push("Sin duración del programa (catálogo).");
    }else{
      if(totalHours > progHours){
        badgeClass = "badge danger";
        rules.push(`Horas programadas (${totalHours}) superan la duración del programa (${progHours}). Debe ajustar.`);
              const sugISO = suggestEndDateForTargetHours(c, progHours);
        if(formEls.approxDateBadge){
          if(sugISO && formEls.fechaFin.value !== sugISO){
            formEls.approxDateBadge.textContent = `Fecha fin aprox.: ${fmtDMYYYY(sugISO)}`;
            formEls.approxDateBadge.style.display = "inline-flex";
            formEls.approxDateBadge.dataset.iso = sugISO;
          }else{
            formEls.approxDateBadge.style.display = "none";
            formEls.approxDateBadge.dataset.iso = "";
            formEls.approxDateBadge.textContent = "";
          }
        }
}else if(totalHours < progHours){
        badgeClass = "badge warn";
        rules.push(`Horas programadas (${totalHours}) son menores a la duración del programa (${progHours}). Debe ajustar.`);
      }else{
        badgeClass = "badge";
        rules.push("Horas programadas coinciden con la duración del programa.");
      }
    }
    formEls.hoursBadge.className = badgeClass;

    // Render filas
    selected.forEach(iso=>{
      const dt = parseISODate(iso);
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(toDDMMYYYY(iso))}</td>
        <td style="text-transform:capitalize;">${escapeHtml(dayNameES(dt))}</td>
        <td>${escapeHtml(c.prog.hStart)} – ${escapeHtml(displayEndMinusOneMinute(c.prog.hEnd))}</td>
        <td style="font-weight:900;">${hoursPerDay}</td>
        <td><a class="linklike" data-remove="${escapeHtml(iso)}">Quitar día</a></td>
      `;
      formEls.daysTbody.appendChild(tr);
    });

    // bind remove
    formEls.daysTbody.querySelectorAll("a[data-remove]").forEach(a=>{
      a.addEventListener("click", (e)=>{
        e.preventDefault();
        const iso = a.getAttribute("data-remove");
        if(!iso) return;
        // Quitar del calendario avanzado si aplica
        try{ if(c?.days?.byDate) c.days.byDate.delete(iso); }catch(e){}
        c.days.excluded.add(iso);
        // ajustar activeISO si aplica
        if(c?.days?.activeISO === iso){
          const k = Array.from((c.days.byDate||new Map()).keys()).sort();
          c.days.activeISO = k.length ? k[0] : null;
        }
        computeSelectionAndHours(c);
        syncFechaFinToLastSelected(c);
        recalcSelectionAndHours(true);
        toast("Día quitado.");
      });
    });

    formEls.hoursRulesHint.innerHTML = rules.join(" ");
  }

  // =========================
  // Navegación / Guardar
  // =========================
  $("btnPrev").addEventListener("click", ()=> setActiveCourse(STATE.activeIndex - 1));
  $("btnNext").addEventListener("click", ()=> setActiveCourse(STATE.activeIndex + 1));

  $("btnGuardar").addEventListener("click", ()=>{
    const c = getActive();
    if(!c) return;

    // Capturar estado actual
    syncUIToState(c);

    // Recalcular selección con el estado actual (evita reportes desincronizados)
    rebuildDaysByDateFromState(c, { preserveExisting:true, fillIfEmpty:true });


    // Validación UI (campos obligatorios)
    const missing = validateRequiredUIBeforeSave(c);
    if(missing.length){
      formEls.saveHint.textContent = "Faltan campos por llenar: " + missing.join(", ") + ".";
      formEls.saveHint.style.color = "var(--danger)";
      toast("Faltan campos obligatorios.");
      return;
    }

    // Validar ficha completa
    const errors = validateCourse(c);
    if(errors.length){
      formEls.saveHint.textContent = errors.join(" ");
      formEls.saveHint.style.color = "var(--danger)";
      toast("Hay campos por corregir.");
      return;
    }

    // Re-crear ocupación para este curso: liberar y asignar
    releaseOccupancyForCourse(c.idx);
    assignOccupancyForCourse(c);

    // Guardar flag
    c.saved = true;
    formEls.saveHint.textContent = "Ficha guardada.";
    formEls.saveHint.style.color = "var(--ok)";
    renderSidebar();
    renderCourseForm();

    // Auto-avanzar si hay siguiente
    if(STATE.activeIndex < STATE.cursos.length-1){
      setActiveCourse(STATE.activeIndex + 1);
    }
  });

  function syncUIToState(c){
    // Programa
    c.program.code = formEls.programCode.value.trim();
    c.program.name = formEls.programName.value.trim();
    c.program.hours = Number(formEls.programHours.value || 0) || null;

    // Meta
    c.meta.area = formEls.areaOcupacion.value.trim();
    c.meta.ficha = formEls.numFichaCaracterizacion.value.trim();
    c.meta.codigoEmpresa = formEls.codigoEmpresa.value.trim();

    // Empresa
    c.empresa.full = !!formEls.chkEmpresa.checked;
    c.empresa.aula = formEls.empresaAula.value.trim();
    c.empresa.municipio = formEls.empresaMunicipio.value || "Ibagué";
    c.empresa.dpto = "Tolima";

    if(c.empresa.full){
      c.empresa.nombre = formEls.empresaNombre.value.trim();
      c.empresa.convenio = formEls.empresaConvenio.value.trim();
      c.empresa.contacto = formEls.empresaContacto.value.trim();
      c.empresa.celular = formEls.empresaCelular.value.trim();
      c.empresa.correo = formEls.empresaCorreo.value.trim();
    }else{
      c.empresa.nombre = EMPRESA_DEFAULTS.nombre;
      c.empresa.convenio = EMPRESA_DEFAULTS.convenio;
      c.empresa.contacto = EMPRESA_DEFAULTS.contacto;
      c.empresa.celular = EMPRESA_DEFAULTS.celular;
      c.empresa.correo = EMPRESA_DEFAULTS.correo;
    }

    // Prog
    c.prog.start = formEls.fechaInicio.value;
    c.prog.end = formEls.fechaFin.value;
    c.prog.hStart = formEls.horaInicio.value;
    c.prog.hEnd = formEls.horaFin.value;
    c.prog.cupo = String(formEls.cupo.value || "").trim();
    c.prog.obs = formEls.observaciones.value.trim();

    // Días y horas
    computeSelectionAndHours(c);
  }

  function validateCourse(c){
    const errs = [];
    if(!c.program.code) errs.push("Código de programa es obligatorio.");
    if(!STATE.catalogMap.get(c.program.code)) errs.push("Código de programa no existe en el catálogo.");
    if(!c.meta.area) errs.push("Área Ocupación es obligatoria.");
    if(!c.program.name) errs.push("Nombre del programa no se encontró (verifique código).");
    if(!c.program.hours) errs.push("Horas del programa no disponibles.");

    // Empresa
    if(!c.empresa.aula) errs.push("Aula (dirección) es obligatoria.");
    if(!c.empresa.municipio) errs.push("Municipio es obligatorio.");

    if(c.empresa.full){
      if(!c.empresa.nombre) errs.push("Nombre de empresa es obligatorio (modo empresa).");
      if(!c.empresa.contacto) errs.push("Contacto de empresa es obligatorio (modo empresa).");
      // convenio opcional
    }

    // Programación
    const s = parseISODate(c.prog.start);
    const e = parseISODate(c.prog.end);
    if(!s || !e) errs.push("Fechas inicio/fin son obligatorias.");
    else if(e < s) errs.push("Fecha finalización debe ser mayor o igual a inicio.");

    const m1 = minutesFromHHMM(c.prog.hStart);
    const m2 = minutesFromHHMM(c.prog.hEnd);
    if(m1===null || m2===null || m2<=m1) errs.push("Horas inicio/fin inválidas.");
    else{
      if((m1%60)!==0 || (m2%60)!==0) errs.push("Horas deben ser en bloques de 1 hora (minutos en 00).");
    }

    const cupo = Number(c.prog.cupo || 0);
    if(!cupo || cupo < 1) errs.push("Cupo debe ser un número mayor a 0.");
    // cupo menor al recomendado: se permite (queda como restricción en Observaciones)
    // Días
    if(!c.days.selected || c.days.selected.length===0) errs.push("Debe seleccionar al menos 1 día programable.");
    // Validación de horas
    const total = Number(c.computed.totalHours || 0);
    const ph = Number(c.program.hours || 0);

    // Regla: no puede sobrepasar horas del programa.
    if(ph && total > ph){
      errs.push("No puede sobrepasar la duración del programa.");
    }

    // Regla: si total < horas del programa, se permite guardar/generar (queda como advertencia en Observaciones).
    // Conflictos con otras fichas
    const conflicts = findConflictsAgainstOccupancy(c);
    if(conflicts.length){
      errs.push(`Conflictos de horario detectados con otras fichas: ${conflicts.slice(0,3).join(" | ")}${conflicts.length>3 ? " ..." : ""}`);
    }

    return errs;
  }

  // -------------------------
  // Validación UI antes de guardar (marca campos faltantes en rojo y muestra el mensaje debajo)
  // -------------------------
  function clearAllFieldErrors(){
    document.querySelectorAll(".input-invalid").forEach(el=> el.classList.remove("input-invalid"));
    document.querySelectorAll(".field-error").forEach(el=> el.remove());
  }

  function setFieldError(el, msg){
    if(!el) return;
    el.classList.add("input-invalid");
    const field = el.closest(".field") || el.parentElement;
    if(!field) return;
    let err = field.querySelector(".field-error");
    if(!err){
      err = document.createElement("div");
      err.className = "field-error";
      field.appendChild(err);
    }
    err.textContent = msg || "Falta por llenar.";
  }

  function validateRequiredUIBeforeSave(c){
    clearAllFieldErrors();
    const missing = [];

    const req = (el, label, msg)=>{
      const v = el ? String(el.value || "").trim() : "";
      if(!v){
        setFieldError(el, msg || "Falta por llenar.");
        missing.push(label);
        return false;
      }
      return true;
    };

    // Campos base
    req(formEls.programCode, "Código de programa");
    if(formEls.programCode.value.trim() && STATE.catalogMap && !STATE.catalogMap.get(formEls.programCode.value.trim())){
      setFieldError(formEls.programCode, "Código no existe en el catálogo.");
      missing.push("Código de programa válido");
    }

    req(formEls.areaOcupacion, "Área Ocupación");
    req(formEls.empresaAula, "Aula");
    req(formEls.empresaMunicipio, "Municipio");

    req(formEls.fechaInicio, "Fecha inicio");
    // Regla: fecha de inicio >= hoy
    if(formEls.fechaInicio.value){
      const minISO = formEls.fechaInicio.getAttribute("min") || todayISO();
      if(formEls.fechaInicio.value < minISO){
        setFieldError(formEls.fechaInicio, "La Fecha Inicio no puede ser anterior a hoy.");
        missing.push("Fecha inicio (>= hoy)");
      }
    }

    req(formEls.fechaFin, "Fecha finalización");
    req(formEls.horaInicio, "Hora inicio");
    req(formEls.horaFin, "Hora fin");

    const cupoV = Number(formEls.cupo.value || 0);
    if(!cupoV || cupoV < 1){
      setFieldError(formEls.cupo, "Debe ser mayor a 0.");
      missing.push("Cupo");
    }

    // Modo empresa completo
    if(formEls.chkEmpresa && formEls.chkEmpresa.checked){
      req(formEls.empresaNombre, "Nombre empresa");
      req(formEls.empresaContacto, "Contacto empresa");
    }

    // Programación mínima (no es un input, se reporta en el mensaje general)
    const allFilled = !!(formEls.fechaInicio.value && formEls.fechaFin.value && formEls.horaInicio.value && formEls.horaFin.value);
    const sel = (c && c.days && Array.isArray(c.days.selected)) ? c.days.selected : [];
    if(allFilled && (!sel || sel.length===0)){
      missing.push("Programación de días");
    }

    // Sin duplicados
    return Array.from(new Set(missing));
  }


  function findConflictsAgainstOccupancy(c){
    const out = [];
    const startMin = minutesFromHHMM(c.prog.hStart);
    const endMin = minutesFromHHMM(c.prog.hEnd);
    if(startMin===null || endMin===null) return out;
    const labelMe = courseLabel(c);
    for(const iso of (c.days.selected || [])){
      const entries = STATE.occupancy.get(iso) || [];
      for(const e of entries){
        if(e.cursoIndex === c.idx) continue;
        if(Math.max(startMin, e.startMin) < Math.min(endMin, e.endMin)){
          out.push(`${iso} (${labelMe}) solapa con ${e.label}`);
          break;
        }
      }
    }
    return out;
  }

  function courseLabel(c){
    const n = (c.program.name || `Curso ${c.idx+1}`).trim();
    return `Curso ${c.idx+1} – ${n}`;
  }

  function releaseOccupancyForCourse(courseIdx){
    for(const [iso, arr] of STATE.occupancy.entries()){
      const filtered = arr.filter(x => x.cursoIndex !== courseIdx);
      if(filtered.length) STATE.occupancy.set(iso, filtered);
      else STATE.occupancy.delete(iso);
    }
  }

  function assignOccupancyForCourse(c){
    const label = courseLabel(c);

    const fallbackStartMin = minutesFromHHMM(c.prog.hStart);
    const fallbackEndMin = minutesFromHHMM(c.prog.hEnd);

    for(const iso of (c.days.selected || [])){
      if(!STATE.occupancy.has(iso)) STATE.occupancy.set(iso, []);

      const set = (c?.days?.byDate && c.days.byDate.get(iso)) ? c.days.byDate.get(iso) : null;

      // Si hay horas específicas por día, registrar por bloque de 1 hora (más exacto para cruces)
      if(set && set.size){
        for(const h of Array.from(set).sort((a,b)=>a-b)){
          const startMin = Number(h) * 60;
          const endMin = (Number(h) + 1) * 60;
          STATE.occupancy.get(iso).push({ startMin, endMin, cursoIndex:c.idx, label });
        }
        continue;
      }

      // Fallback: usar rango genérico (Inicio/Fin) si no existe detalle por día
      if(Number.isFinite(fallbackStartMin) && Number.isFinite(fallbackEndMin) && fallbackEndMin > fallbackStartMin){
        STATE.occupancy.get(iso).push({ startMin:fallbackStartMin, endMin:fallbackEndMin, cursoIndex:c.idx, label });
      }
    }
  }

  // =========================
  // PDFs
  // =========================
  
  // Recalcular desde el STATE (sin depender del botón "Calcular") para evitar PDFs/guardado desincronizados.
  // - Limpia días fuera de rango o excluidos
  // - Completa días faltantes según días de semana y horas configuradas
  // - Aplica bloqueos por cruce/ocupación
  function rebuildDaysByDateFromState(c, opts){
    try{ ensureWeekdayState(c); }catch(e){}
    try{ ensureCourseSchedule(c); }catch(e){}

    const options = opts || {};
    const preserveExisting = (options.preserveExisting !== false); // default true
    const fillIfEmpty = (options.fillIfEmpty !== false);           // default true

    const ov = (typeof validateInternalScheduleOverlap === "function") ? validateInternalScheduleOverlap(c) : { ok:true };
    const ignoreExtra = !ov.ok;

    const baseObj = (typeof computeBaseSelectableDays === "function") ? computeBaseSelectableDays(c) : { baseSelectable:[] };
    const baseSelectable = Array.isArray(baseObj.baseSelectable) ? baseObj.baseSelectable : [];
    const baseSet = new Set(baseSelectable);

    if(!c.days) c.days = {};
    if(!(c.days.excluded instanceof Set)) c.days.excluded = new Set(Array.isArray(c.days.excluded) ? c.days.excluded : []);
    if(!(c.days.byDate instanceof Map)) c.days.byDate = new Map();

    // Mantener solo excluidos dentro del rango base
    c.days.excluded = new Set(Array.from(c.days.excluded).filter(iso => baseSet.has(iso)));

    // Reiniciar bloqueados (derivado)
    c.days.blocked = new Set();

    // Limpieza defensiva
    for(const iso of Array.from(c.days.byDate.keys())){
      if(!baseSet.has(iso) || c.days.excluded.has(iso)){
        c.days.byDate.delete(iso);
      }
    }

    // Completar / normalizar selección por día
    for(const iso of baseSelectable){
      if(c.days.excluded.has(iso)) continue;

      const allowed = (typeof allowedHoursFromCourse === "function")
        ? allowedHoursFromCourse(c, iso, { ignoreExtra })
        : [];

      let cur = c.days.byDate.get(iso);
      const hasCur = (cur instanceof Set) && cur.size > 0;

      const out = new Set();

      if(preserveExisting && hasCur){
        // Conservar selección del usuario, pero limpiar horas inválidas / ocupadas
        for(const h of cur){
          if(allowed.includes(h) && !(typeof isHourBusyPrior === "function" && isHourBusyPrior(iso, h, c.idx))){
            out.add(h);
          }
        }
        // Si quedó vacío y se permite, completar con el bloque permitido completo
        if(out.size === 0 && fillIfEmpty){
          for(const h of allowed){
            if(!(typeof isHourBusyPrior === "function" && isHourBusyPrior(iso, h, c.idx))){
              out.add(h);
            }
          }
        }
      }else{
        // Nuevo día: seleccionar todas las horas permitidas disponibles
        for(const h of allowed){
          if(!(typeof isHourBusyPrior === "function" && isHourBusyPrior(iso, h, c.idx))){
            out.add(h);
          }
        }
      }

      if(out.size){
        c.days.byDate.set(iso, out);
      }else{
        c.days.byDate.delete(iso);
        c.days.blocked.add(iso);
      }
    }

    // Derivados
    const selected = Array.from(c.days.byDate.keys()).sort();
    c.days.selected = selected;

    let total = 0;
    for(const iso of selected){
      total += (c.days.byDate.get(iso)?.size || 0);
    }
    c.computed = c.computed || {};
    c.computed.totalHours = total;
    c.computed.hoursPerDay = selected.length ? (Math.round((total/selected.length)*100)/100) : 0;

    return { selected, totalHours: total, hoursPerDay: c.computed.hoursPerDay, ignoreExtra };
  }

function triggerDownloadBlob(blob, filename, idx){
    try{
      const a = document.createElement("a");
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = filename;
      a.style.display = "none";
      document.body.appendChild(a);
      const delay = (Number(idx)||0) * 250; // espaciar descargas múltiples
      setTimeout(()=>{
        a.click();
        setTimeout(()=>{
          try{ URL.revokeObjectURL(url); }catch(e){}
          try{ a.remove(); }catch(e){}
        }, 1500);
      }, delay);
    }catch(e){
      // fallback: si falla, se intentará pdf.save
      throw e;
    }
  }


  $("btnGenerarPDFs").addEventListener("click", ()=>{
    const total = STATE.cursos.length;
    if(!total) return;

    // Re-validar todo antes de generar
    syncUIToState(STATE.cursos[STATE.activeIndex]); // asegura activo
    for(const c of STATE.cursos){
      rebuildDaysByDateFromState(c, { preserveExisting:true, fillIfEmpty:true });
      const errs = validateCourse(c);
      if(errs.length){
        toast(`No se puede generar: Curso ${c.idx+1} tiene pendientes.`);
        setActiveCourse(c.idx);
        formEls.saveHint.textContent = errs.join(" ");
        formEls.saveHint.style.color = "var(--danger)";
        return;
      }
    }

    // Generar secuencialmente (un PDF por ficha)
    STATE.cursos.forEach((c, idx)=>{
      rebuildDaysByDateFromState(c, { preserveExisting:true, fillIfEmpty:true });
      const pdf = buildPdfForCourse(c);
      const datePart = todayYYYYMMDD();
      const instructorPart = normalizeFileNamePart(STATE.instructor.nombre);
      const courseShort = (c.program.name || "CURSO").substring(0,10);
      const coursePart = normalizeFileNamePart(courseShort);
      const fileName = `FC_${datePart}_${instructorPart}_${coursePart}.pdf`;      
      // Descargar directamente (sin pestañas)
      try{
        const blob = pdf.output("blob");
        triggerDownloadBlob(blob, fileName, idx);
      }catch(e){
        pdf.save(fileName);
      }
    });

    toast("PDF(s) descargados.");
  });

  function todayYYYYMMDD(){
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${y}${m}${dd}`;
  }

  
  function buildPdfForCourse(c){
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit:"mm", format:"a4" });

    const pageW = 210, pageH = 297;
    const margin = 10;

    const SENA_LOGO_DATAURL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAABoCAIAAAB5SZn1AAAVZklEQVR4nO1deVRTVxr/3nvZSVhCgiJMZQ8J2lI74wqIaGfGMqcdZ3TUse3p6YxtFSitxdYFCSLi0ta2I9a249Haaj1tteBpO/VYWxdEqtaFIqsCyiKQEAQSIMtb5o8gkhtCgkkwnsPv+I/3fe/e7/5y7/2++333PjAMw2AMTgArKip60Do83MAYhnnQOjzcwB+0Ag89xhh0FmMMOosxBp3FGIPOYoxBZ8F60ArYBM3QGqPGxJgAgI2x/Tn+OOaJv7cnMtimb/ui6YvvW7+/1n1NR+oAQMgSTvKelDw++Z/B/xzHG/egFbSAx3nUXzR+oaxS3ui7AQBAAZi1wwAIAIAIfsQm+aYlwUseoIYIPIvB3KpcZbWSxmggbUiwAKfxjdEbM6MzR1Uz2/AgBj+u/3jFbysYmoHhNcIBw7CPH/14eejyUdJsWHgKg7U9tTNOzVAb1XboMwMDKUdaklgS7hXuds3swVOs24d1H6oZx+gDAAbUjPqjuo/cq5Nj8AgGO4wdhbcLgRrJOxR80/xNh7HDXTo5DI9gsEZX09TXBPRI3qGhSd9Uo6txl04OwyMY7DB2GAmjo1PYDAaMhHFsDPbjvq2ZJ5hBj2CQjbNHNoXNoIGNs12vzQjhEQyGeIX44X4j0wUHP9wvxCvETSqNRBEPQKggNNY31rxvcxQEPOr7aKgg1F06OQyPYJCNs18OfXmktviV0FfGZvE9/DXwr/Ml8x0NFbFgvmT+gsAF7tXJMXgKg1yCuzN2p0wgA449UQ7IBLKdsTu5BHc0NLMHT2EQAMK9wgunFc70nglcG3rhAFyY6T2zcFqhJ+yIzfCUyMIAukxdu+p27b21t7anFggA85kUBoCCcK/wFye+mBKW4sP2ecBaDoLHMWiG2qAu7ii+0HGhi+wCAB+Wz1Tx1FniWVKu9EGrhsJDGXyI4EHr4EOK+8w0dZm6ukxdnabObrK7h+oREkIRSyTmiH3YPiKWCBHWktpeqtfBmn1YPjyCRzGUxqixjlZLOVLrjJ2O1PVQPQP/xQG3ldijGKrd2O5InY5jZAyq9Kqvbn91XHW8vKtcZVCZaBMFFEmTLIxFYAQH5wTyAmO8YxZMWLAwaCGf4Jvfyq3O3d2wG0wONIDD51M+f2bCM8365rjTcZ1kp4WbjcPKkJV5MXlIh9+/8f72uu39qRUCgjhBZ2ef9ef4W1efWZ6569auwYFIjIUpo5SrIlaNiIfBGAGD5zTn/n3135W9lWbLCADABmAACCAxkmRIg8mg7dXW6GsKVAVHmo98/ofPzeNRT+m1pNYieTRgZK1gpI0AQDO0jtRpSS2yUXmn/h0JR5IRlTG40EAb7tXPgA7XDZlqOaE68X7d+3pKb/GQhrzqvCcDnpzsPdlxKgbDUQa1pHbF1RWVvZX9QwkDHsZ7dsKzsb6xBBA6Svez+ucfVD8M7G2P6o7uu7Xv1fBXravCMVzhpRAQAmsSGWAkXMkwalAUtb5qfQAv4PlHnndQczPaDe2vl72uh7v0EQA0AANAg4bWZJRlFE4vHJg0I4KjDHYYO6q0VfdGBAbeHO/nJz4f7x9vLsiIzEgrTSvVlTIkAwDABhM91LzFgEfwDk09NMl70pAN2czU4QA0AA1GMKb+lurD8nlmwjMOKk8zdGZF5rW+a+ZxiuHYi7978ejto+1kO9AAJjjefnzPzT1p4WkOVjgYjjLoxfISs8WtZGv//KVBZVA9efbJSaJJj/s9LhfKI0WRaeFpjwge4eG84asiabKgueDSnUvoAxwm8iYmShOtXyEwYrrf9F86fqEYCmjQktqXS18O4AXMEM9wRPnClsK9jXsHVp5Z3rPyY/N92b7v3noXjP3d2Vyz+Y8Bf5SJZI5UOBiOMijhSNZEr8kozyA5JJD9U8BAGy7pLl3qvQQYgAlEhEjKkT7h90Ty+OSnxz/tx/EboiIGjIwxqzZriHWQDcnC5CEZpIBKj0if3jH93fp3za23mdqWXVxWOL3wUZ9Hh9e8qa/pjbI3TLTJPLj5wM+LyePhvNVRq7+5/U09WW/uSxvVllGWcWT6EQ5ud2dugRFY8fTw9B+m/7AscFmIIATHcCAAWAAMgAnAAMCAltLW6eu+Vn39QukLcUVxZzVnbdZFDf2PwGzECDHAMXzLpC0Lxy0Ec0CLhHpj/bOXnm3uax4mxkUyZEZZxk3yZv/6g0NKSEq8JB4AxnHHKaOVbOLuu0b4rv27/978r+OEmDEyb2ZewLx5AfM0Rk21tvpcx7mK7oobuhu1PbXtxnYjywjkXS4AKvoqVlxZcTrhtJgjRiph4+zlE5cH8gKRJY8GWiFU2GqaYig2xv4w9sOmkqZfdL+AEcAEZb1ly68sDxGE2Fo8DzYe/Krlq4Hlm8WwtKRWWaE0N62n9V7g1Yl19r9OQ05VzjzpvBHNZUcZ/LXz13dq3ul/B2OxcXauIjeIH0QyZLepu7an9ifVTztqd6gNd7PmRrhGXqvSVc0Uz7SoCAMOwVkVsSpceD/BFSlX+tnvP3vq3FM3qBtAARjhB9UPPOANGZ2t0latvbaWGWScSIb8uOnjexOPASDhHvs0qGjVmmtrvp72NQt3lBlH5bpMXV+qvrynKAFCljAjMiOYHyzmiH3ZviKW6EDjAbVJ3b9gY8DBOEKW0LoqiqaKNcVqo9r6Ec3QYo44WhQ9jCaRwshPp3y64MICNaiBAqBBD3pUiAGSJldfW91CtgzoA0S/+4J46QB3PRsAMMG36m8PNR167pHn7FHSD0cZnOo3dZpw2vme82Ds/+ny6/O/bPrSn+MvYou6jd0t+pZuurtfORYAAS9MeEEhspqVDOgp/YuXX8SGcqkZFpMsST464+jwysySzNrz+J6ll5b20r1Dzl8OwdlVt+s79Xf9bjYG3izvPEWemCumGYvhimN4u6F9bfnaHqoHGAAGKIZaX7F+lv+sMK8wR5hxlEERS3TwDwfTf0s/oT5hwAzmQjWjVpvU/T42fvd3JiGKH7U8ZHlqWCoLYwEAyZBgudZTmI0THmzoo/oAgAHGQBuADQMWgLacqE8HPv22/O20sjSaTVuQSADN0D+rfl5fuf7ezoeAlRNXpoSn2Opdlbbqw5YPB3ZNjdD4+m+vfzXtKy5uPww+AksS7hVeOL3wSueVM5ozFV0VKqNKR+rM2jPAeLG8ArgB0aLoKb5TnvB9YrABSZIk4RiOM/btPo3Rk0WTAcCH7ZMWltZL92IMBgAMxsi80NX9lbBXcAwv15UPrpnBGAlH0mpofWHiCwRDmHXjE/z0iPRh2n1L9hafxTdSxv6ZgQEOeJu+7RHBI3Z1dio+SDO0+WIjwzCeech5FDAWYXUWdmbx5c7L5bry+zmS4QRojP69z+9jvGOQ8vLu8l+7fnVkNXAlcIgRxkzxnWLruR0GP2v47APVB2BwtVrDAAeeiVecUGz9xEAbXrnyip6tH9VflAvpAen3zyAH54ABRpVBNrwZ8eaQGk/xnfJmxJs5tTkOBWtdh+F3yh62/LMgghORGp5q63lqeGoEJ8KjbsF4GIMA66PXD5PSlHKl66PXj6Y+duFJDLIgziducfDi4aUWBy+O84nznGFoRxEjbQQ7AdORgAKbV20w4GLcbEW23VA7n+BnK7KTf0k2YAabB4dZMLKzdMOA15+6sQU7DC793VKFr2Jkp+xtgKTJgtsFJzQnhrakbFg0blGSJAkprtZWB/GDkAhFkiRp0fhFB9oOwJBdw2Ge37wFExY4Hl8ZDgQ8JnpsmOej6lFrSe3sM7Ov6K6gIxEDf65/UXyRXCRH5OcUzXkp5KWXQl9CqqrUVsYXxWsMGnQYsuBx4eOnE05bp63dhFFdB0UsUbx//BBtEpAamorQBwAf1X10qe/Slpotjb2NyCO5SJ4amjrEVMUh3j9+1OiDUWZQR+qKNEXomkCAnC9PDUM9mLqeuh03doARbppubqnZYp3DSw1LlfPlKIkUFGmKzHdqRwejyuD+hv1XdVetV9W3ZG9Zp4m31mxtpVvN2cj9jfvPac4hAhKu5C3ZW2hdFFzVXd3fsN+Veg+L0WOwoa9hW/U2hrYcSmxI8E2wvi9cpCk60Hygf+/BQC/0bijfYKDQvdGS4CUJvglI8JGhmW3V2xr6GlzcARsYPQa3V29vJBsRQ8wH/saYjUggU0/rN5Rv6GP67k1cE5zsPLn31l6kTi7O3RizkQ+WDhANjWTj9urtLu6ADYwSg5c7L+9v3I/uZ1mwKHBRoiQRET7QcODMnTOoMANba7Y29qEmJVGSuChwEeqVmWB/4/7LnZddoLo9jAaDJENmVWTpMMvVHQcpIV0nW4cItxna8qrzhvCxKGgwNeRV51nXv062TkpIka7oMF1WRRbJ2PLgXYbRYLDgdsGx9mPomCIgLTzNOjO7vXp7val+aK/bBPsa9p1uP40Uy0SytPA01Cib4Fj7sYLbBc7pbh9u96h1lC7uVFyprtTCBLMgkhtZMqcEOeVX2lU6u2h2F9llMwLIhtk+s4/FHUNO52iMmhknZ1w3XEfO2D0mfOxs4lkhMUTS1VVw+xj8qO6j0r5SxIPBGCxTnonQRzFUVkVWF2ObPgAwwemu03tvoibFn+OfKc80p6UG1QilfaXuvgrvXgYb+xp3XN+BOoAsSPBNsI7BHL199H+q/9kMPQyAgm0126xNyuLgxQm+CahJoWDH9R3Wwi6EexncVr2thW6xYBADHsZTKpSIB9Nl6upf+O0uKjQ0GBs2V21Girk4V6lQ8jCeRSqfgha6ZVv1Nic6YQduZLBYU7yvYR9qQNiwNGjpHOkcRHhn7c5yg1VKCwNgDxU/ImFfw75T7aeQ4jnSOUuDliIOttn+FGuGSLy4BO5ikGTI3KrcXuhFDhT4Y/5rotYgwjW6mp11O9H5i4MAF/zF/y+JvokYoIdEjLgxszzT+orAmqg1/pi/hV1moBd6c6ty3eTZuIvBI81HjmuOo6QQ8Fr4a1HCKEQ4pypHRaksBiAGAkJwaOqhb2d++1P8T5tjNqOamqC4q3jPzT1IVVHCqNfCX0M9GxKOa44faT7iRIdswi3eTKepM+F0QllvGeJbyPiyc4nnkBOFP6p+fKrkKZKyJJsDK4NX7ordZf6fgTbMLZpb3F1ssSbgMJ4zviSxJEQQMvjVDmPHzFMzq/uqEf9psmDymdlnfNm+zndwMNwyBj+p/6Ssr8zaqq6VrUXo09N6ZYWSxC1FcQgkAt+MenOggItzs+XZLNpyRaShlW61NilijnitbC3aNgllfWWf1H8y8t7YgesZrOute+/Ge6gHw4YkcZJ1DObTW5+WaEtQa4PB2qi1EwUTB5fNC5j3XPBz1vvfz5o/O6E6gVS7JHhJkjgJNSkUvHfjvbreupH1xx5czCDN0HlVea1kK2JVBZggW56N3Klu6GvYXL0Ztb8siPON+1fIv6wr3xC9IYgdZKEyA0YwZlZkdpu6B0tyCW62PFuACSyVg1ayNa8qDzlC6CRczGBJR8nBpoPo/GXD4sDF5vPfg/FOzTtNpibEW2QDO1uRLSAEYIVQr9CMyAzr/e/57vPWga94SfziwMXoMCThYNPBko6SEXTJHlzJoJE2Zldk6zHLM7k4BOAB1jGY8x3n99zaY831kglL5krn2mri5bCXp4mmobzQsLVma10POj3XydYF4AFIF/WYPrsie/gE5ojgSgYPNx8+eeckSgoL0sLTIoQRg8tIhtxYtbEP67PwFnGQYtLhP83Ix/nZ8mw2Y0khDW10W25VLiIcIYxIC09Dl04STt45ebj5sGN9sg+XMXjHdCenModiKAtSWBDNjU4JQ4/fHm4+fKz9mLW3+HrE69beIoI/j/vzPwL/Yb3x+OL2Fz+qfkSEU8JSornRFiQyQDFUTmXOHdMd+71yAC5jML82v9pYPUQMRpaJXG5SG9Q5VTkMwyBcxwpiV4atdKStLHlWABGAmBQDY8gsz9SS2sGSfhy/TNkQMZtqY3V+bb4jbdmFaxis66nLr8u3jsEkiZMWBi9EhPNr8yt7KxFhgiFyFDkOfoIiShiVHpZuPT0vdF+w3qUsDF6YJE6yjtnk1+W7xLNxAYMMMJurNqtoFWJVBZggS56FxGDKu8v/U/cfa64XjFuQPD7Z8UbTItJi+bGo+jRsrdl6XXd9cBkX52bJswSYAInZqGjVpspN9j76ah8uYPCU+tTB5oPWMZhlQcsSJAmDy8wLUCd0WqiNgRgXKxXKEZ1lF7FEm2I2cTDLs5EMqGhVdmU24vElSBKWBS2zXjoPNR06pT7leKNDwlkGjbRRWak0gAGJwUgx6eqo1Yjw8bbj37R+Y52xezX8VVvXjYfB/HHz/x74d/QbSSY43HL4hBrdpayOWi3FpEjMxoAZlJVKJz0bZxnEMXyudC5O4xZzBIf0iPRIYeRgSS2pVVYqSYxEDIiCpxj+soctEBihlCv9Mf8hdilWJiVSGJkekW4hiQFO43Olc528x+EsgyyMpZQrt8ds57K5AxeIYvgx1h7MJ/WfXOy+iHgwBBBZ8qz7jpfIRLJVEausY1kXuy/urtuNCKeEpcTwY/qFMeCyudtjtivlSvPFq/uGa2zxG5Fv7IzZyWVxgQAMsHWydQgpN3tv7rixw3oL/CfJn/4W9Ddnml4RtkLBV6Ak0vD29bcRk+LL9l0nW4cBBgRwWdydMTvfiHzDmabNcJk/uDx0+e7Ju3kEb454zsIg1IPZUr3lNnUbMSDeuPcmxSY25tQ3BP3YfhvlGwmEQgbamXZlhRIxKQuDFs4Rz+ERvN2Td7vqk+oujrAW3C4I4AbM8p81uPBM+5n5JfN7ScuIPwdWTVz17uR3nW/UxJgWn19c0F5gcaQVAw7BKZha8NT4pwYLF2uKVQbVggku+3ah2zPueko/v3j+qc5TSLw6jB92bva5cVzX/KmMa93X4oviO02WX/ghIFYYe2b2GbceyHR7xv1g40GUPgAA2CDb4Cr6AGCS96S0UKuDHxRc7b36wY0PXNXKkHDvGGzRt0w9ObWJbLLwAVmQ4JtwbNax+/tCji20G9vjTsWh6REO+ILvxcSLSHDIhXDvGKSBfjLgSR/wAc7dpjAQYIJcRa5r6QMACUeSrcjGAR9wqoANCr5ik2KTe/+sDuN+VHZXvlb6muR7CRwF+BZSr6a6qSETbUouTobvAAoh5FjI2zVvawwaN7U1gNFg0IwqbVXK1ZTJJybX99S7r5ULHRdkJ2Q5lTktfS3ua2UwRvuGtpbUuvuqQrep25vt7dYmBmPsjruz8KSbiQ8nxhh0FmMMOosxBp3FGIPOYoxBZzHGoLP4PzXh2Bp1F0UEAAAAAElFTkSuQmCC";

    function rect(x,y,w,h,fill=false,border=true){
      if(fill){
        doc.setFillColor(230,230,230);
        doc.rect(x,y,w,h,"F");
      }
      if(border){
        doc.setDrawColor(0,0,0);
        doc.setLineWidth(0.35);
        doc.rect(x,y,w,h);
      }
    }
    function sectionBar(x,y,w,h,text,fontSize=9.4){
      // Barra de sección estilo formulario (como el diseño de referencia)
      doc.setFillColor(230,230,230);
      doc.setDrawColor(0,0,0);
      doc.setLineWidth(0.55);
      doc.rect(x,y,w,h,"FD"); // Fill + Draw
      doc.setFont("helvetica","bold");
      doc.setFontSize(fontSize);
      // Ajuste vertical óptico
      const ty = y + (h * 0.72);
      doc.text(String(text||""), x + w/2, ty, { align:"center" });
    }


    function label(x,y,txt,fs=9,bold=false,alignLeft=true){
      doc.setFont("helvetica", bold ? "bold" : "normal");
      doc.setFontSize(fs);
      doc.setTextColor(0,0,0);
      if(alignLeft){
        doc.text(String(txt||""), x, y);
      }else{
        doc.text(String(txt||""), x, y, { align:"center" });
      }
    }

    function centerTextInBox(txt,x,y,w,h,fs=10,bold=true,color=null){
      doc.setFont("helvetica", bold ? "bold" : "normal");
      doc.setFontSize(fs);
      if(color) doc.setTextColor(color[0],color[1],color[2]); else doc.setTextColor(0,0,0);
      doc.text(String(txt||""), x + w/2, y + h/2 + 0.5, { align:"center", baseline:"middle" });
      doc.setTextColor(0,0,0);
    }

    function drawFitTextUpper(txt,x,y,w,h,baseFs=11,minFs=7,bold=true){
      const t = String(txt||"").toUpperCase();
      for(let fs=baseFs; fs>=minFs; fs--) {
        doc.setFont("helvetica", bold ? "bold" : "normal");
        doc.setFontSize(fs);
        const lines = doc.splitTextToSize(t, w-4);
        const lineH = fs*0.35 + 2;
        if(lines.length * lineH <= h-3) {
          let y0 = y + (h - lines.length*lineH)/2 + fs*0.35;
          lines.forEach((ln,i)=> doc.text(ln, x+2, y0 + i*lineH));
          return;
        }
      }
      // fallback
      doc.setFont("helvetica", bold ? "bold" : "normal");
      doc.setFontSize(minFs);
      const lines = doc.splitTextToSize(t, w-4);
      let y0 = y + 3;
      lines.slice(0,4).forEach((ln,i)=> doc.text(ln, x+2, y0 + i*(minFs*0.35+2)));
    }


    function drawFitTextUpperCentered(txt,x,y,w,h,baseFs=10,minFs=7,bold=true){
      const t = String(txt||"").toUpperCase();
      for(let fs=baseFs; fs>=minFs; fs--) {
        doc.setFont("helvetica", bold ? "bold" : "normal");
        doc.setFontSize(fs);
        const lines = doc.splitTextToSize(t, w-4);
        const lineH = fs*0.35 + 2;
        if(lines.length * lineH <= h-3) {
          let y0 = y + (h - lines.length*lineH)/2 + fs*0.35;
          lines.forEach((ln,i)=> doc.text(ln, x + w/2, y0 + i*lineH, { align:"center" }));
          return;
        }
      }
      doc.setFont("helvetica", bold ? "bold" : "normal");
      doc.setFontSize(minFs);
      const lines = doc.splitTextToSize(t, w-4);
      let y0 = y + 3;
      lines.slice(0,4).forEach((ln,i)=> doc.text(ln, x + w/2, y0 + i*(minFs*0.35+2), { align:"center" }));
    }

    function toDDMMYYYYSafe(iso){ return toDDMMYYYY(iso); }

    function normalizePhoneToE164CO(raw){
      const digits = String(raw||"").replace(/\D/g,"");
      if(!digits) return null;
      // si viene con 57 al inicio, respetar; si no, asumir CO
      const d = digits.startsWith("57") ? digits : ("57"+digits);
      return d;
    }

    
    function writeLinkCentered(text,url,x,y,w,h,fs=10,minFs=6.2){
      const t = String(text||"");
      doc.setFont("helvetica","normal");
      doc.setTextColor(0,0,255);

      // reducir fuente hasta que quepa
      let f = fs;
      for(; f>=minFs; f-=0.2){
        doc.setFontSize(f);
        if(doc.getTextWidth(t) <= Math.max(1, w-2)) break;
      }

      const maxW = Math.max(1, w-2);

      // si aún no cabe, partir en líneas (máx 3) y centrar verticalmente
      if(doc.getTextWidth(t) > maxW){
        doc.setFontSize(minFs);
        const lines = doc.splitTextToSize(t, maxW).slice(0,3);
        const lineH = (minFs*0.35 + 2);
        const blockH = lines.length * lineH;
        let y0 = y + (h - blockH)/2 + (minFs*0.35);
        lines.forEach((ln,i)=>{
          const tw = doc.getTextWidth(ln);
          const tx = x + (w - tw)/2;
          doc.textWithLink(String(ln||""), tx, y0 + i*lineH, { url });
        });
      } else {
        const tw = doc.getTextWidth(t);
        const tx = x + (w - tw)/2;
        const ty = y + h/2 + 0.5;
        doc.textWithLink(t, tx, ty, { url });
      }

      doc.setTextColor(0,0,0);
    }

    function buildObservacionesAuto(c){
      const hasByDate = !!(c?.days?.byDate && (c.days.byDate instanceof Map ? c.days.byDate.size : Object.keys(c.days.byDate||{}).length));
      const hasSelected = !!(c?.days?.selected && Array.isArray(c.days.selected) && c.days.selected.length);
      if(!hasByDate && !hasSelected) return "";

      // === Restricciones (rojo) y advertencias (amarillo) para incluir en PDF ===
      const red = [];
      const yellow = [];

      // Condición 1: mínimo 5 días hábiles (lunes a viernes) antes de la fecha de inicio
      if(c?.prog?.start){
        const bd = countBusinessDaysFromTomorrowTo(c.prog.start);
        if(bd < 5){
          red.push({ n:1, text:"La ficha se está solicitando con menos de 5 días hábiles." });
        }
      }

      // Condición 2: cupo mínimo 30
      const cupo = Number(c?.prog?.cupo || 0);
      if(cupo && cupo < 30){
        red.push({ n:2, text:`El cupo de esta ficha se está solicitando con ${cupo}. Recuerde que el mínimo son 30 aprendices.` });
      }

      // Condición 3: duración > 60
      const progHours = Number(c?.program?.hours || 0);
      if(progHours && progHours > 60){
        red.push({ n:3, text:"La duración de este curso supera las 60 horas, en las cuales el instructor podrá solicitar apertura." });
      }

      // Condición 4: A la medida = SI
      const aMedida = String(c?.program?.aMedida || "").trim().toUpperCase();
      if(aMedida === "SI"){
        red.push({ n:4, text:"Este curso que se solicita es a la medida." });
      }

      // Advertencias (amarillo): menos horas programadas que la duración del programa (no bloquea)
      const totalH = Number((c?.computed?.totalHours) || 0);
      if(progHours && totalH && totalH < progHours){
        yellow.push(`El curso se programará con menos horas: ${totalH} de ${progHours} (Duración).`);
      }

      // === Programación detallada ===
      const out = [];

      // Secciones de restricciones/advertencias (numeración continua; amarillo al final)
      const allObs = [];
      red.forEach(it => allObs.push({ color:"red", text: String(it && it.text ? it.text : it) }));
      yellow.forEach(t => allObs.push({ color:"yellow", text: String(t) }));
      if(allObs.length){
        out.push("RESTRICCIONES / ADVERTENCIAS:");
        allObs.forEach((it,idx)=> out.push(`${idx+1}. ${it.text}`));
        out.push("");
      }

      // Programación
      if(hasByDate){
        const weekdayNames = ["domingo","lunes","martes","miércoles","jueves","viernes","sábado"];

        function rangesFromSet(setHours){
          const arr = Array.from(setHours||[]).sort((a,b)=>a-b);
          const ranges = [];
          let s=null, prev=null;
          for(const h of arr){
            if(s===null){ s=h; prev=h; continue; }
            if(h===prev+1){ prev=h; continue; }
            ranges.push([s, prev+1]);
            s=h; prev=h;
          }
          if(s!==null) ranges.push([s, prev+1]);
          return ranges;
        }
        function toHHMM(n){
          if(!isFinite(n)) return "";
          const hh = Math.floor(n);
          const mm = Math.round((n - hh) * 60);
          return `${pad2(hh)}:${pad2(mm)}`;
        }
        function rangesToStr(ranges){
          if(!ranges.length) return "";
          const parts = [];
          for(const [a,b] of ranges){
            parts.push(`${toHHMM(a)}–${toHHMM(b)}`);
          }
          return parts.join(" / ");
        }

        // Agrupar por día de semana y patrón de horas
        const groups = new Map();
        const entries = c.days.byDate instanceof Map ? Array.from(c.days.byDate.entries()) : Object.entries(c.days.byDate||{});
        for(const [iso,setHours] of entries){
          const dt = parseISODate(iso);
          if(!dt) continue;
          const wd = weekdayNames[dt.getDay()] || "";
          const ranges = rangesFromSet(setHours);
          const rangesStr = rangesToStr(ranges);
          const key = wd + "||" + rangesStr;
          if(!groups.has(key)) groups.set(key, { weekday:wd, rangesStr, dates:[] });
          groups.get(key).dates.push(iso);
        }

        if(groups.size){
          out.push("PROGRAMACIÓN:");

          const hs = String(c?.prog?.hStart || "").trim();
          const he = String(c?.prog?.hEnd || "").trim();
          const genericRSGlobal = (hs && he) ? `${hs} a ${he}` : null;

          const toDDMM = (iso)=>{
            const dt = parseISODate(iso);
            if(!dt) return iso || "";
            return `${String(dt.getDate()).padStart(2,"0")}/${String(dt.getMonth()+1).padStart(2,"0")}`;
          };

          // Recolectar por día de semana
          const perW = new Map(); // weekday -> [{rs, iso}]
          for(const [iso,setHours] of entries){
            const dt = parseISODate(iso);
            if(!dt) continue;
            const wd = weekdayNames[dt.getDay()] || "";
            if(wd === "domingo") continue;
            const rs = rangesToStr(rangesFromSet(setHours));
            if(!perW.has(wd)) perW.set(wd, []);
            perW.get(wd).push({ rs, iso });
          }

          const order = ["lunes","martes","miércoles","jueves","viernes","sábado"];
          for(const wd of order){
            const arr = perW.get(wd);
            if(!arr || !arr.length) continue;

            let genericRS = genericRSGlobal;
            if(!genericRS){
              const freq = new Map();
              arr.forEach(o=> freq.set(o.rs, (freq.get(o.rs)||0)+1));
              genericRS = Array.from(freq.entries()).sort((a,b)=> b[1]-a[1])[0][0];
            }

            out.push(`${wd.toUpperCase()}: ${genericRS}`);

            const exMap = new Map();
            arr.forEach(o=>{
              if(o.rs !== genericRS){
                if(!exMap.has(o.rs)) exMap.set(o.rs, []);
                exMap.get(o.rs).push(o.iso);
              }
            });

            if(exMap.size){
              out.push("  cambios:");
              for(const [rs, isos] of Array.from(exMap.entries())){
                const dds = isos.slice().sort().map(toDDMM);
                out.push(`    ${rs}: ${dds.join(", ")}`);
              }
            }
            out.push("");
          }
        }
      } else {
        // Programación basada en fechas seleccionadas + horario diario
        const sel = (c?.days?.selected && Array.isArray(c.days.selected)) ? c.days.selected.slice().sort() : [];
        if(sel.length){
          out.push("PROGRAMACIÓN:");
          const hs = String(c?.prog?.hStart || "").trim();
          const he = String(c?.prog?.hEnd || "").trim();
          if(hs && he) out.push(`Horario diario: ${hs}–${he}`);
          out.push(`Fechas (${sel.length}):`);
          const dd = sel.map(toDDMMYYYY);
          for(let i=0;i<dd.length;i+=6){
            out.push(dd.slice(i,i+6).join(", "));
          }
          out.push("");
        }
      }

      return out.join("\n").trim();
    }



    // Outer border (todos los bordes)
    const ox = margin, oy = margin, ow = pageW-2*margin, oh = pageH-2*margin;
    doc.setDrawColor(0,0,0);
    doc.setLineWidth(0.35);
    doc.rect(ox, oy, ow, oh);

    // === Encabezado superior (como imagen de referencia) ===
    const innerX = margin + 2;
    const innerW = pageW - 2*margin - 4;

    const headerY = margin + 2;
    const headerH = 22;
    const logoW = 32;

    // Cajas de encabezado
    doc.setDrawColor(0,0,0);
    doc.setLineWidth(0.55);
    doc.rect(innerX, headerY, logoW, headerH);
    doc.rect(innerX + logoW, headerY, innerW - logoW, headerH);

    // Logo
    try{
      doc.addImage(SENA_LOGO_DATAURL, "PNG", innerX + 3.2, headerY + 1.2, logoW - 6.4, headerH - 2.4);
    }catch(e){}

    // Textos del encabezado
    const hx = innerX + logoW;
    const hw = innerW - logoW;
    const hc = hx + hw/2;

    doc.setTextColor(0,0,0);
    doc.setFont("helvetica","bold");
    doc.setFontSize(11);
    doc.text("Servicio Nacional de Aprendizaje SENA", hc, headerY + 5.2, { align:"center" });
    doc.setFontSize(10);
    doc.text("Regional Tolima", hc, headerY + 10.0, { align:"center" });
    doc.text("Centro de Comercio Y Servicios", hc, headerY + 14.6, { align:"center" });
    doc.setFontSize(9.3);
    doc.text("FICHA DE CARACTERIZACIÓN DE CURSO ESPECIAL", hc, headerY + 19.2, { align:"center" });

    // Fecha de elaboración (con hora)
    const now = new Date();
    const dd = String(now.getDate()).padStart(2,"0");
    const mm = String(now.getMonth()+1).padStart(2,"0");
    const yyyy = now.getFullYear();
    const HH = String(now.getHours()).padStart(2,"0");
    const MIN = String(now.getMinutes()).padStart(2,"0");
    const fechaElab = dd + "/" + mm + "/" + yyyy + " " + HH + ":" + MIN;


    // Barra NOTA (gris)
    const yNota = headerY + headerH;
    sectionBar(innerX, yNota, innerW, 6.5, "NOTA: TODOS LOS CAMPOS CON (*) DEBEN ESTAR CLARAMENTE DILIGENCIADOS.", 9.4);

    // === Utilidad: texto ajustado para cajas bajas (dos líneas posibles) ===
    function drawFitTextUpperTight(txt,x,y,w,h,baseFs=7.2,minFs=5.2,bold=true){
      const t = String(txt||"").toUpperCase();
      for(let fs=baseFs; fs>=minFs; fs-=0.2){
        doc.setFont("helvetica", bold ? "bold" : "normal");
        doc.setFontSize(fs);
        const lines = doc.splitTextToSize(t, Math.max(1, w-4));
        const lineH = fs*0.30 + 1.1; // compacto
        const blockH = lines.length * lineH;
        if(blockH <= h-2){
          const y0 = y + (h - blockH)/2 + fs*0.30;
          lines.forEach((ln,i)=> doc.text(ln, x + 2, y0 + i*lineH));
          return;
        }
      }
      doc.setFont("helvetica", bold ? "bold" : "normal");
      doc.setFontSize(minFs);
      const one = doc.splitTextToSize(t, Math.max(1, w-4))[0] || "";
      doc.text(one, x + 2, y + h/2 + minFs*0.15, { baseline:"middle" });
    }

    // === Bloque superior (identificación del curso) ===
    let y = yNota + 8.6;
    const ex = margin + 6;
    const rh = 7;
    const gapForm = 2.2;

    // Posiciones tipo formato referencia
    const leftLabelX  = ex;
    const leftBoxX    = 70;
    const leftBoxW    = 40;

    const rightLabelX = 112;
    const rightBoxX   = 150;
    const rightBoxW   = 45;

    // Fila 1: Código programa + N° ficha
    label(leftLabelX, y+5.0, "Codigo Programa de Formacion:*", 9, false);
    rect(leftBoxX, y, leftBoxW, rh, false, true);
    centerTextInBox(c.program.code, leftBoxX, y, leftBoxW, rh, 11.5, true);

    label(rightLabelX, y+5.0, "N° Ficha Caracterizacion:", 8.4, false);
    rect(rightBoxX, y, rightBoxW, rh, false, true);
    centerTextInBox(String(c.meta.ficha||""), rightBoxX, y, rightBoxW, rh, 10, false);

    y += rh + gapForm;

    
    // Fila 2: Código empresa + Área ocupación
    const rh2 = 14; // más alto para permitir el contenido del Área de Ocupación (como referencia)
    label(leftLabelX, y + (rh2*0.72), "Codigo Empresa:", 9, false);
    rect(leftBoxX, y, leftBoxW, rh2, false, true);
    centerTextInBox(String(c.meta.codigoEmpresa||"").toUpperCase(), leftBoxX, y, leftBoxW, rh2, 10, false);

    label(rightLabelX, y + (rh2*0.72), "Área Ocupacion:*", 9, false);
    rect(rightBoxX, y, rightBoxW, rh2, false, true);
    drawFitTextUpperCentered(c.meta.area || "", rightBoxX, y, rightBoxW, rh2, 8.8, 6.2, true);

    y += rh2 + gapForm;

    // Fila 3: Nombre programa + Horas
    doc.setFont("helvetica","normal");
    doc.setFontSize(9);
    doc.text(["Nombre Programa", "de Formación:*"], leftLabelX, y+3.6);

    const horasLabelX = 150;
    const horasBoxX   = 170;
    const horasBoxW   = 25;

    const progBoxW = (horasLabelX - 4) - leftBoxX;
    rect(leftBoxX, y, progBoxW, rh, false, true);
    drawFitTextUpperTight(c.program.name || "", leftBoxX, y, progBoxW, rh, 9.2, 6.0, true);

    label(horasLabelX, y+5.0, "Horas: *", 9, false);
    rect(horasBoxX, y, horasBoxW, rh, false, true);
    centerTextInBox(String(c.program.hours||""), horasBoxX, y, horasBoxW, rh, 10.5, true);

    y += rh + 4.2;

    // === INFORMACION DE LA EMPRESA* (2 columnas) ===
    sectionBar(innerX, y, innerW, 6.0, "INFORMACION DE LA EMPRESA*", 9.2);
    y += 7.2;

    const rowX = innerX + 2;
    const rowW = innerW - 4;
    const colGap = 8;
    const colW = (rowW - colGap) / 2;
    const c1X = rowX;
    const c2X = rowX + colW + colGap;

    // Row 1
    label(c1X, y+5.0, "Nombre de empresa*", 9, false);
    rect(c1X+36, y, colW-36, rh, false, true);
    drawFitTextUpperCentered((c.empresa.nombre || ""), c1X+36, y, colW-36, rh, 8.6, 6.0, true);

    label(c2X, y+5.0, "Convenio:", 9, false);
    rect(c2X+22, y, colW-22, rh, false, true);
    drawFitTextUpperCentered((c.empresa.convenio || ""), c2X+22, y, colW-22, rh, 8.6, 6.0, true);

    y += rh + gapForm;

    // Row 2
    label(c1X, y+5.0, "Celular empresa:", 9, false);
    rect(c1X+36, y, colW-36, rh, false, true);
    const empPhone = normalizePhoneToE164CO(c.empresa.celular);
    if(empPhone){
      const empDisp = String(c.empresa.celular||"").trim() || empPhone;
      writeLinkCentered(empDisp, `https://wa.me/${empPhone}`, c1X+36, y, colW-36, rh, 8.3);
    } else {
      centerTextInBox(String(c.empresa.celular||""), c1X+36, y, colW-36, rh, 9, false);
    }

    label(c2X, y+5.0, "Correo empresa:", 9, false);
    const empMailOff = 30;
    rect(c2X+empMailOff, y, colW-empMailOff, rh, false, true);
    const empMail = String(c.empresa.correo||"").trim();
    if(empMail && empMail.toUpperCase() !== "NO APLICA"){
      writeLinkCentered(empMail, `mailto:${empMail}`, c2X+empMailOff, y, colW-empMailOff, rh, 8.0);
    } else {
      centerTextInBox(empMail.toUpperCase(), c2X+empMailOff, y, colW-empMailOff, rh, 8.6, false);
    }

    y += rh + gapForm;

    // Row 3
    doc.setFont("helvetica","normal");
    doc.setFontSize(8.2);
    doc.text("Aula (Dirección detallada)*", c1X, y+5.0);
    rect(c1X+36, y, colW-36, rh, false, true);
    drawFitTextUpperTight(c.empresa.aula || "", c1X+36, y, colW-36, rh, 7.2, 5.2, false);

    doc.setFont("helvetica","normal");
    doc.setFontSize(9);
    doc.text(["Nombre del", "contacto *"], c2X, y+3.6);
    rect(c2X+22, y, colW-22, rh, false, true);
    drawFitTextUpperTight(c.empresa.contacto || "", c2X+22, y, colW-22, rh, 8.6, 6.0, true);

    y += rh + 4;

    // === INFORMACION DEL INSTRUCTOR (A)* ===
    sectionBar(innerX, y, innerW, 6.0, "INFORMACION DEL INSTRUCTOR (A)*", 9.2);
    y += 7.2;

    // Nombre completo (ancho completo)
    label(rowX, y+5.0, "Nombre Completo:*", 9, false);
    rect(rowX+36, y, rowW-36, rh, false, true);
    drawFitTextUpperTight(STATE.instructor.nombre || "", rowX+36, y, rowW-36, rh, 8.8, 6.0, true);

    y += rh + gapForm;

    // Cédula + Celular (fila 1)
    label(rowX, y+5.0, "N° Cedula:*", 9, false);
    const cedLabelW = 24;
    const cedBoxW = 36;
    rect(rowX+cedLabelW, y, cedBoxW, rh, false, true);
    centerTextInBox(String(STATE.instructor.cedula||""), rowX+cedLabelW, y, cedBoxW, rh, 9.0, false);

    const celLabelX = rowX + cedLabelW + cedBoxW + 4;
    label(celLabelX, y+5.0, "Celular", 9, false);
    const celLabelW = 16;
    const celBoxW = 28;
    rect(celLabelX + celLabelW, y, celBoxW, rh, false, true);
    const instPhone = normalizePhoneToE164CO(STATE.instructor.celular);
    if(instPhone){
      const instDisp = String(STATE.instructor.celular||"").trim() || instPhone;
      writeLinkCentered(instDisp, `https://wa.me/${instPhone}`, celLabelX + celLabelW, y, celBoxW, rh, 8.2);
    } else {
      centerTextInBox(String(STATE.instructor.celular||""), celLabelX + celLabelW, y, celBoxW, rh, 9.0, false);
    }

    y += rh + gapForm;

    // Correo sena (fila 2, más ancho)
    label(rowX, y+5.0, "Correo sena:", 9, false);
    const mailLabelW = 24;
    const mailBoxX = rowX + mailLabelW;
    const mailBoxW = rowW - mailLabelW;
    rect(mailBoxX, y, mailBoxW, rh, false, true);

    const instMail = String(STATE.instructor.correo||"").trim();
    if(instMail){
      writeLinkCentered(instMail, `mailto:${instMail}`, mailBoxX, y, mailBoxW, rh, 8.8);
    } else {
      centerTextInBox("", mailBoxX, y, mailBoxW, rh, 9, false);
    }

    y += rh + 4;

    // === INFORMACION DE PROGRAMACION* (se mantiene la lógica existente) ===
    // Programación header
    rect(margin+2, y, pageW-2*margin-4, 6, true, true);
    doc.setFont("helvetica","bold");
    doc.setFontSize(9.5);
    doc.text("INFORMACION DE PROGRAMACION*", pageW/2, y+4.4, { align:"center" });
    y += 7;

    // Fechas + cupo
    label(ex, y+5.0, "Fechas", 9, false);
    label(ex+28, y+5.0, "Inicio:", 9, false);
    rect(ex+44, y, 34, rh, false, true);
    centerTextInBox(toDDMMYYYYSafe(c.prog.start), ex+44, y, 34, rh, 9.5, false);

    label(ex+86, y+5.0, "Finalización:", 9, false);
    rect(ex+112, y, 34, rh, false, true);
    centerTextInBox(toDDMMYYYYSafe(c.prog.end), ex+112, y, 34, rh, 9.5, false);

    label(ex+154, y+5.0, "Cupo:", 9, false);
    rect(ex+166, y, 18, rh, false, true);
    centerTextInBox(String(c.prog.cupo||""), ex+166, y, 18, rh, 9.5, false);

    y += rh + gapForm + 1;

    // Horario (corrido a la derecha) + Días (con X) [incluye Horario 2 si aplica]
    const rowStartY = y;
    const headers = ["LU","MA","MI","JU","VI","SA"];
    const cellW = 8;
    const htX = ex+24;
    const htH = 12;
    const daysX = htX + 66;
    const mpX = daysX + cellW*headers.length + 10;
    const mpW = 34; // ajustado para no salir del borde
    const mpRh = 6;
    const mpGap = 1.5;
    const rowGap = 2;

    const drawHorarioRow = (rowY, labelText, hStart, hEnd, weekdaysArr)=>{
      label(ex, rowY+5.0, labelText, 9, false);

      // caja Desde/Hasta
      rect(htX, rowY, 58, htH, false, true);
      doc.setFont("helvetica","bold");
      doc.setFontSize(8.5);
      doc.text("Desde", htX+18, rowY+3.6, { align:"center" });
      doc.text("Hasta", htX+44, rowY+3.6, { align:"center" });
      doc.setLineWidth(0.25);
      doc.line(htX, rowY+4.5, htX+58, rowY+4.5);
      doc.line(htX+29, rowY, htX+29, rowY+htH);

      doc.setFont("helvetica","normal");
      doc.setFontSize(9.5);
      doc.text(String(hStart||""), htX+14.5, rowY+8.9, { align:"center" });
      doc.text(String(hEnd||""), htX+43.5, rowY+8.9, { align:"center" });

      // Días (LU..SA)
      const daysY = rowY-0.5;
      const daysH = 12;
      rect(daysX, daysY, cellW*headers.length, daysH, false, true);
      doc.line(daysX, daysY+4.2, daysX+cellW*headers.length, daysY+4.2);
      for(let i=1;i<headers.length;i++) doc.line(daysX+i*cellW, daysY, daysX+i*cellW, daysY+daysH);

      doc.setFont("helvetica","bold");
      doc.setFontSize(8);
      headers.forEach((h,i)=> doc.text(h, daysX + i*cellW + cellW/2, daysY+3.2, { align:"center" }));

      const set = new Set();
      for(const v of (weekdaysArr||[])){
        const n = normalizeDowAny(v);
        if(n) set.add(n);
      }
      const markFor = (h)=>{
        if(h==="LU") return set.has(1);
        if(h==="MA") return set.has(2);
        if(h==="MI") return set.has(3);
        if(h==="JU") return set.has(4);
        if(h==="VI") return set.has(5);
        if(h==="SA") return set.has(6);
        return false;
      };
      doc.setFont("helvetica","normal");
      doc.setFontSize(10);
      headers.forEach((h,i)=>{
        const mark = markFor(h) ? "x" : "";
        doc.text(mark, daysX + i*cellW + cellW/2, daysY+9.2, { align:"center" });
      });
    };

    // Horario principal
    drawHorarioRow(rowStartY, "Horario:", c.prog.hStart, c.prog.hEnd, c.prog.weekdays);

    // Horario complementario (si está activo)
    const ex2 = (c.prog && c.prog.extra) ? c.prog.extra : null;
    const hasExtra = !!(ex2 && ex2.enabled);
    if(hasExtra){
      drawHorarioRow(rowStartY + htH + rowGap, "H2:", ex2.hStart, ex2.hEnd, ex2.weekdays);
    }

    // Municipio/Dpto (se mantiene alineado con la primera fila)
    label(mpX-10, rowStartY+4.6, "Mpio.", 9, false);
    rect(mpX, rowStartY, mpW, mpRh, false, true);
    drawFitTextUpperCentered(c.empresa.municipio || "", mpX, rowStartY, mpW, mpRh, 8.2, 6.0, true);

    const dptoY = rowStartY + mpRh + mpGap;
    label(mpX-10, dptoY+4.6, "Dpto.", 9, false);
    rect(mpX, dptoY, mpW, mpRh, false, true);
    drawFitTextUpperCentered("Tolima", mpX, dptoY, mpW, mpRh, 8.2, 6.0, true);

    // avanzar Y según el bloque más alto
    const schedH = hasExtra ? (htH*2 + rowGap) : htH;
    const mpH = (mpRh*2 + mpGap);
    y = rowStartY + Math.max(schedH, mpH) + 3;

// Observaciones (sin borde; menor altura)
    label(ex, y+5.0, "Observaciones:", 9, false);

    const sigTopY = pageH - margin - 26; // inicio área firmas

    // Ancho total disponible para texto y tabla
    const fullX = ex;
    const fullW = pageW - 2*margin;

    // Texto del usuario (observaciones)
    const obsUser = String(c?.prog?.obs || "").trim();

    // Restricciones / Advertencias (como líneas separadas, debajo de Observaciones)
    const restr = [];
    if(c?.prog?.start){
      const bd = countBusinessDaysFromTomorrowTo(c.prog.start);
      if(bd < 5) restr.push("La ficha se está solicitando con menos de 5 días hábiles.");
    }
    const cupoV = Number(c?.prog?.cupo || 0);
    if(cupoV && cupoV < 30){
      restr.push(`El cupo de esta ficha se está solicitando con ${cupoV} aprendices. Recuerde que el mínimo son 30 aprendices.`);
    }
    const progH = Number(c?.program?.hours || 0);
    if(progH && progH > 60){
      restr.push("La duración de este curso supera las 60 horas, en las cuales el instructor podrá solicitar apertura.");
    }
    const aMed = String(c?.program?.aMedida || "").trim().toUpperCase();
    if(aMed === "SI"){
      restr.push("Este curso que se solicita es a la medida.");
    }

    // Advertencia (si aplica)
    const totalHPdf = Number((c?.computed?.totalHours) || 0);
    if(progH && totalHPdf && totalHPdf < progH){
      restr.push(`El curso se programará con menos horas: ${totalHPdf} de ${progH} (Duración).`);
    }

    // --- Render texto (Observaciones + Restricciones) ---
    const lh = 3.4;
    const textX = fullX;
    const textW = fullW;

    const obsTextY = y + 9.0;
    let obsTextH = 0;

    doc.setFont("helvetica","normal");
    doc.setFontSize(6.6);
    doc.setTextColor(0,0,0);

    const lines = [];
    if(obsUser){
      const l1 = doc.splitTextToSize(obsUser, textW);
      l1.forEach(ln => lines.push(String(ln)));
    }
    // Restricciones: una por línea (con wrap si se requiere)
    if(restr.length){
      if(lines.length) lines.push(""); // línea en blanco entre obs y restricciones
      restr.forEach(t=>{
        const ll = doc.splitTextToSize(String(t), textW);
        ll.forEach(ln => lines.push(String(ln)));
      });
    }

    if(lines.length){
      // Dejar espacio mínimo para que al menos el encabezado y algunas filas de tabla entren en la primera página.
      const minTableSpace = 65;
      const maxLines = Math.max(1, Math.floor((sigTopY - obsTextY - minTableSpace) / lh));
      const drawLines = lines.slice(0, maxLines);
      if(lines.length > drawLines.length && drawLines.length){
        drawLines[drawLines.length-1] = String(drawLines[drawLines.length-1]) + " …";
      }
      doc.text(drawLines, textX, obsTextY);
      obsTextH = drawLines.length * lh;
    }

    // --- PROGRAMACIÓN (después de Restricciones) ---
    const topY = obsTextY + obsTextH + 6.0;

    doc.setFontSize(7.6);
    doc.setFont("helvetica","bold");
    doc.setTextColor(0,0,0);
    doc.text("PROGRAMACIÓN:", fullX, topY);

// Tabla de programación (una sola)
    // Construir filas de tabla de programación (Día | Horario | Fechas asignadas)
    const programTableRows = [];
    const _progHorasNum = Number(c?.program?.hours || 0);

    (function(){
      const byDate = c?.days?.byDate;
      if(!(byDate && (byDate instanceof Map) && byDate.size)) return;

      const wdLabel = (wd)=>{
        switch(wd){
          case 1: return "LU";
          case 2: return "MA";
          case 3: return "MI";
          case 4: return "JU";
          case 5: return "VI";
          case 6: return "SA";
          default: return "";
        }
      };

      const rangesFromSet = (setHours)=>{
        const arr = Array.from(setHours||[]).filter(v=>Number.isFinite(v)).sort((a,b)=>a-b);
        const out = [];
        let s = null, prev = null;
        for(const h of arr){
          if(s===null){ s=h; prev=h; continue; }
          if(h === prev + 1){ prev = h; continue; }
          out.push([s, prev + 1]);
          s = h; prev = h;
        }
        if(s!==null) out.push([s, prev + 1]);
        return out;
      };

      // wd (1..6) -> Map(horarioKey -> {a,b, isos:[]})
      const perDay = new Map();

      for(const [iso,setHours] of Array.from(byDate.entries())){
        const dt = parseISODate(iso);
        if(!dt) continue;
        const wd = dt.getDay(); // 0..6
        if(wd===0) continue; // no domingo
        const ranges = rangesFromSet(setHours);
        if(!ranges.length) continue;

        if(!perDay.has(wd)) perDay.set(wd, new Map());
        const m = perDay.get(wd);

        for(const rg of ranges){
          const a = rg[0], b = rg[1];
          const key = `${pad2(a)}-${pad2(b)}`;
          if(!m.has(key)) m.set(key, { a, b, isos: [] });
          m.get(key).isos.push(iso);
        }
      }

      // Orden de días: Horario 1 ∪ Horario 2 (LU..SA)
      let wdOrder = [1,2,3,4,5,6];
      try{
        if(typeof selectedDowSet === "function"){
          const s = selectedDowSet(c);
          if(s && s.size){
            wdOrder = Array.from(s).filter(n=>n>=1 && n<=6).sort((a,b)=>a-b);
          }
        }
      }catch(e){}


      for(const wd of wdOrder){
        const m = perDay.get(wd);
        if(!m) continue;

        const entries = Array.from(m.entries()).map(([hor,obj])=>({ horario: hor, a: obj.a, b: obj.b, isos: obj.isos }));
        entries.sort((x,y)=> (x.a - y.a) || (x.b - y.b) || x.horario.localeCompare(y.horario));

        for(const it of entries){
          const fechasArr = it.isos.slice().sort().map(iso=>{
            const dt = parseISODate(iso);
            if(!dt) return "";
            return `${pad2(dt.getDate())}/${pad2(dt.getMonth()+1)}`;
          }).filter(Boolean);

          let fechas = "";
          if(fechasArr.length <= 10){
            fechas = fechasArr.join("; ");
          } else {
            const chunks = [];
            for(let i=0; i<fechasArr.length; i+=10){
              chunks.push(fechasArr.slice(i, i+10).join("; "));
            }
            fechas = chunks.join(";\n");
          }

          programTableRows.push({ day: wdLabel(wd), horario: it.horario, fechas });
        }
      }
    })();


    const tableY = topY + lh + 1.4;
    const tableX = fullX;
    const tableW = fullW;
    const maxTableBottomY = pageH - margin - 6; // permitir más filas; firmas se mueven si es necesario

    // Parámetros comunes de tabla
    const cellPadX = 1.2;
    const cellPadY = 1.2;
    const lineH = 4.2;

    let _progWasTruncated = false;

    
    const drawProgramTablePaged = (rowsIn, tableX, tableTopY, tableW)=>{
      const rowsSrc = (rowsIn && rowsIn.length) ? rowsIn : [{ day:"", horario:"", fechas:"" }];

      let lastEndY = tableTopY;

      // Mantener el ancho total de la tabla (no recortar filas por encoger la tabla).
      // Solo ajustar (hacer más angostas) las columnas Día y Horario.
      const clamp = (v, lo, hi)=> Math.max(lo, Math.min(hi, v));

      // Medición consistente con el cuerpo de tabla
      doc.setFont("helvetica","normal");
      doc.setFontSize(9);

      const measureW = (txt, bold)=>{
        doc.setFont("helvetica", bold ? "bold" : "normal");
        return doc.getTextWidth(String(txt||""));
      };

      const dayNeed = Math.max(
        measureW("Día", true),
        ...rowsSrc.map(r => measureW(r.day, false))
      ) + 2*cellPadX + 4;

      const horNeed = Math.max(
        measureW("Horario", true),
        ...rowsSrc.map(r => measureW(r.horario, false))
      ) + 2*cellPadX + 4;

      const dayW = clamp(dayNeed, 12, 18);
      const horW = clamp(horNeed, 20, 32);

      // Ancho requerido por "Fechas Asignadas" según el texto más largo (línea más larga)
      const maxLineWidth = (txt, bold)=>{
        const parts = String(txt||"").split("\n");
        let mx = 0;
        for(const p of parts){
          mx = Math.max(mx, measureW(p, bold));
        }
        return mx;
      };

      const fecNeed = Math.max(
        maxLineWidth("Fechas Asignadas", true),
        ...rowsSrc.map(r => maxLineWidth(r.fechas, false))
      ) + 2*cellPadX + 4;

      // Ajustar el ancho total de tabla al contenido (sin exceder el ancho disponible)
      const TWNeeded = dayW + horW + Math.max(20, fecNeed);
      const TW = Math.min(tableW, TWNeeded);
      const fecW = Math.max(20, TW - dayW - horW);

      // Centrar la tabla cuando el ancho calculado (TW) sea menor al ancho disponible (tableW)
      const tableXCentered = tableX + Math.max(0, (tableW - TW) / 2);

      const headH = 9.2;

      const makeRow = (dayTxt, horTxt, fecTxt)=>{
        const tDay = String(dayTxt || "");
        const tHor = String(horTxt || "");
        const tFec = String(fecTxt || "");
        const lDay = doc.splitTextToSize(tDay, Math.max(1, dayW - cellPadX*2));
        const lHor = doc.splitTextToSize(tHor, Math.max(1, horW - cellPadX*2));
        const lFec = doc.splitTextToSize(tFec, Math.max(1, fecW - cellPadX*2));
        const maxL = Math.max(lDay.length || 1, lHor.length || 1, lFec.length || 1);
        const rowH = maxL*lineH + cellPadY*2;
        return { tDay, tHor, tFec, lDay, lHor, lFec, rowH };
      };

      const prepared = rowsSrc.map(r => makeRow(r.day, r.horario, r.fechas));

      const drawHeader = (x, y)=>{
        doc.setFont("helvetica","bold");
        doc.setFontSize(9);
        doc.setFillColor(245,245,245);
        doc.setDrawColor(0,0,0);
        doc.setLineWidth(0.2);

        doc.rect(x, y, TW, headH, "F");
        doc.rect(x, y, TW, headH);
        doc.line(x + dayW, y, x + dayW, y + headH);
        doc.line(x + dayW + horW, y, x + dayW + horW, y + headH);

        const hFecLines = doc.splitTextToSize("Fechas Asignadas", Math.max(1, fecW - cellPadX*2));
        doc.text("Día", x + cellPadX, y + 6.1);
        doc.text("Horario", x + dayW + cellPadX, y + 6.1);
        const hfY = (hFecLines.length > 1) ? (y + 4.7) : (y + 6.1);
        doc.text(hFecLines, x + dayW + horW + cellPadX, hfY);
      };

      const drawPage = (startIdx, x, topY)=>{
        let curY = topY;

        drawHeader(x, curY);
        curY += headH;

        doc.setFont("helvetica","normal");
        doc.setFontSize(9);

        const pageRows = [];
        let yProbe = curY;
        let i = startIdx;

        for(; i<prepared.length; i++){
          const rr = prepared[i];
          if(yProbe + rr.rowH > maxTableBottomY) break;
          pageRows.push({ ...rr, y: yProbe });
          yProbe += rr.rowH;
        }

        // Si no cabe ninguna fila (muy raro), forzar al menos una
        if(pageRows.length === 0 && startIdx < prepared.length){
          const rr = prepared[startIdx];
          pageRows.push({ ...rr, y: curY });
          yProbe = curY + rr.rowH;
          i = startIdx + 1;
        }

        const bodyStartY = curY;
        const bodyH = Math.max(0, yProbe - bodyStartY);

        const drawCellTextAt = (lines, xx, yTop, w)=>{
          const x0 = xx + cellPadX;
          const usableW = Math.max(1, w - cellPadX*2);
          const safeLines = (lines && lines.length) ? lines : [""];
          let y0 = yTop + cellPadY + 2.0;
          safeLines.forEach((ln, k)=>{
            doc.text(String(ln||""), x0, y0 + k*lineH, { maxWidth: usableW });
          });
        };

        if(bodyH > 0){
          doc.setDrawColor(0,0,0);
          doc.setLineWidth(0.2);
          doc.rect(x, bodyStartY, TW, bodyH);
          doc.line(x + dayW, bodyStartY, x + dayW, bodyStartY + bodyH);
          doc.line(x + dayW + horW, bodyStartY, x + dayW + horW, bodyStartY + bodyH);

          for(let r=0; r<pageRows.length-1; r++){
            const yLine = pageRows[r].y + pageRows[r].rowH;
            doc.line(x, yLine, x + TW, yLine);
          }

          for(const rr of pageRows){
            drawCellTextAt(rr.lDay, x, rr.y, dayW);
            drawCellTextAt(rr.lHor, x + dayW, rr.y, horW);
            drawCellTextAt(rr.lFec, x + dayW + horW, rr.y, fecW);
          }
        }

        return { nextIndex: i, endY: bodyStartY + bodyH };
      };

      // Render paginado (sin eliminar filas). Si se excede el alto, se crea página(s) adicional(es).
      let idx = 0;
      let first = true;
      while(idx < prepared.length){
        if(first){
          const out = drawPage(idx, tableXCentered, tableTopY);
          lastEndY = out.endY;
          idx = out.nextIndex;
          first = false;
          if(idx >= prepared.length) break;
        } else {
          doc.addPage();

          // Marco mínimo de página (consistencia visual)
          doc.setDrawColor(0,0,0);
          doc.setLineWidth(0.35);
          doc.rect(margin, margin, pageW-2*margin, pageH-2*margin);

          // Encabezado sección
          rect(margin+2, margin+2, pageW-2*margin-4, 6, true, true);
          doc.setFont("helvetica","bold");
          doc.setFontSize(9.5);
          doc.text("INFORMACION DE PROGRAMACION* (CONTINUACIÓN)", pageW/2, margin+2+4.4, { align:"center" });

          // Título de programación
          const contY = margin + 16;
          doc.setFont("helvetica","bold");
          doc.setFontSize(7.6);
          doc.setTextColor(0,0,0);
          doc.text("PROGRAMACIÓN (CONTINUACIÓN):", fullX, contY);

          const out = drawPage(idx, tableXCentered, contY + lh + 1.4);
          lastEndY = out.endY;
          idx = out.nextIndex;
        }
      }

      return { lastEndY };

    };

    const _progTblOut = drawProgramTablePaged(programTableRows, tableX, tableY, tableW);

    // Si la tabla ocupó el espacio reservado para firmas, mover firmas a una nueva página
    if(_progTblOut && typeof _progTblOut.lastEndY === "number" && _progTblOut.lastEndY > (sigTopY - 2)){
      doc.addPage();

      // Marco de página
      doc.setDrawColor(0,0,0);
      doc.setLineWidth(0.35);
      doc.rect(margin, margin, pageW-2*margin, pageH-2*margin);

      // Encabezado
      rect(margin+2, margin+2, pageW-2*margin-4, 6, true, true);
      doc.setFont("helvetica","bold");
      doc.setFontSize(9.5);
      doc.text("INFORMACION DE PROGRAMACION*", pageW/2, margin+2+4.4, { align:"center" });
    }


    // reset color
    doc.setTextColor(0,0,0);
// Firmas (sin borde)

    const sigY = sigTopY;
    const sigW = (pageW - 2*margin - 16) / 2;

    // Instructor: imagen + línea
    if(STATE.instructor.firmaDataUrl){
      try{
        const imgProps = doc.getImageProperties(STATE.instructor.firmaDataUrl);
        const iw = imgProps.width, ih = imgProps.height;
        const maxW = sigW - 10, maxH = 14;
        const scale = Math.min(maxW/iw, maxH/ih);
        const w = iw*scale, h = ih*scale;
        const x = margin+6 + (sigW - w)/2;
        doc.addImage(STATE.instructor.firmaDataUrl, imgProps.fileType || "PNG", x, sigY, w, h);
      }catch(e){}
    }
    doc.setLineWidth(0.25);
    doc.line(margin+6, sigY+16, margin+6+sigW, sigY+16);
    doc.setFont("helvetica","bold");
    drawFitTextUpperCentered(`Instructor (${STATE.instructor.nombre||""})`, margin+6, sigY+16, sigW, 12, 8.5, 6.5, true);

    // Coordinador(a): línea + etiqueta en una línea y nombre en la siguiente
    const cX = margin+6 + sigW + 10;
    doc.line(cX, sigY+16, cX+sigW, sigY+16);
    doc.setFont("helvetica","bold");

    // Ajuste: "COORDINADOR(A) ACADÉMICO(A)" en una línea y luego el nombre del coordinador
    (function(){
      const label = "COORDINADOR(A) ACADÉMICO(A)";
      const name = String(STATE.instructor.coordinador||"").toUpperCase();
      const boxX = cX;
      const boxY = sigY+16;
      const boxW = sigW;
      const boxH = 12;

      for(let fs=7.2; fs>=5.4; fs-=0.2){
        doc.setFontSize(fs);
        const nameLines = doc.splitTextToSize(name, boxW-4).slice(0,2);
        const lines = [label, ...nameLines];
        const lineH = fs*0.35 + 2;
        if(lines.length * lineH <= boxH-1){
          let y0 = boxY + (boxH - lines.length*lineH)/2 + fs*0.35;
          lines.forEach((ln,i)=> doc.text(ln, boxX + boxW/2, y0 + i*lineH, { align:"center" }));
          return;
        }
      }

      // fallback
      doc.setFontSize(5.4);
      const nameLines = doc.splitTextToSize(name, boxW-4).slice(0,2);
      const lines = ["COORDINADOR(A) ACADÉMICO(A)", ...nameLines];
      let y0 = boxY + 3;
      lines.slice(0,4).forEach((ln,i)=> doc.text(ln, boxX + boxW/2, y0 + i*(5.4*0.35+2), { align:"center" }));
    })();

// Fecha de Elaboración en footer (abajo a la derecha)
    doc.setFont("helvetica","normal");
    doc.setFontSize(8.0);
    doc.setTextColor(100, 116, 139);
    doc.text(`Fecha de Elaboración: ${fechaElab}`, pageW - margin, pageH - 5, { align:"right" });
    doc.setTextColor(0,0,0);

    return doc;
  }


  // =========================
  // Reiniciar
  // =========================
  $("btnReiniciar").addEventListener("click", ()=>{
    // reset total
    STATE.catalogLoaded = false;
    STATE.catalogMap = new Map();
    STATE.instructor = { nombre:"", cedula:"", celular:"", correo:"", coordinador:"", firmaDataUrl:"" };
    STATE.numCursos = 1;
    STATE.cursos = [];
    STATE.activeIndex = 0;
    STATE.occupancy = new Map();

    // reset ui
    $("courseSteps").innerHTML = "";
    $("emptyState").style.display = "block";
    $("courseFormWrap").style.display = "none";
    $("instructorSummary").textContent = "Cargue el catálogo y diligencie la información inicial.";
    $("courseHint").textContent = "Primero finalice el paso inicial.";
    $("sidebarBadge").textContent = "Sin iniciar";
    $("sidebarBadge").className = "badge";
    $("btnGenerarPDFs").disabled = true;

    // overlays
    instructorOverlay.classList.remove("show");
    calendarModal.classList.remove("show");
    fileOverlay.classList.add("show");

    // clear file input (best effort)
    try{ fileInput.value = ""; }catch(e){}
    fileStatus.textContent = "";
    $("instructorStatus").textContent = "";
    $("instNombre").value = "";
    $("instCedula").value = "";
    $("instCelular").value = "";
    $("instCorreo").value = "";
    if($("instCorreoActivo")) $("instCorreoActivo").checked = true;
    updateInstructorCorreoUI();
    $("instCoordinador").value = "";
    $("instNumCursos").value = "1";
    try{ $("instFirma").value = ""; }catch(e){}
    $("firmaPreview").style.display = "none";
    $("firmaPlaceholder").style.display = "block";

    toast("Reiniciado.");
  });


  // =========================================================
  // AJUSTE 1: búsqueda por NOMBRE del programa + selección si duplicado
  // AJUSTE 2: selección de HORAS por día (bloques de 1 hora) + recálculo
  // =========================================================

  // Normalización simple para búsquedas
  function normalizeStr(s){
    return (s || "")
      .toString()
      .trim()
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "");
  }

  // Extender STATE para indexación por nombre
  STATE.catalogList = STATE.catalogList || [];
  STATE.catalogNameMap = STATE.catalogNameMap || new Map(); // nameNorm -> array {code,name,hours}
  STATE.catalogNameDisplayMap = STATE.catalogNameDisplayMap || new Map(); // nameNorm -> displayName

  // Reemplazar estructura de curso para soportar horas por día
  function makeCurso(i){
    return {
      idx: i,
      saved: false,
      program: { code:"", name:"", hours:null },
      meta: { area:"", ficha:"", codigoEmpresa:"" },
      empresa: {
        full: false,
        nombre: EMPRESA_DEFAULTS.nombre,
        convenio: EMPRESA_DEFAULTS.convenio,
        aula: "",
        contacto: EMPRESA_DEFAULTS.contacto,
        celular: EMPRESA_DEFAULTS.celular,
        correo: EMPRESA_DEFAULTS.correo,
        municipio: "Ibagué",
        dpto: "Tolima",
      },
      prog: { start:"", end:"", hStart:"", hEnd:"", cupo:"", obs:"", weekdays:[1,2,3,4,5,6], calculated:false },
      days: {
        excluded: new Set(),
        selected: [],          // array ISO (derivado)
        byDate: new Map(),     // iso -> Set(hoursInt)
        activeISO: null,
      },
      computed: { hoursPerDay: 0, totalHours: 0, nonWorkCount: 0, busyCount: 0 },
    };
  }

  // ---------- UI refs (nuevos)
  const programNameList = $("programNameList");
  const programNameHint = $("programNameHint");

  const programPickModal = $("programPickModal");
  const programPickTbody = $("programPickTbody");
  const programPickHint = $("programPickHint");

  $("btnCloseProgramPick").addEventListener("click", ()=> programPickModal.classList.remove("show"));

  const hourList = $("hourList");
  const hourPanelHint = $("hourPanelHint");
  const activeDayLabel = $("activeDayLabel");
  const applyHoursToAll = $("applyHoursToAll");
  const dayHoursBadge = $("dayHoursBadge");
  const hourRules = $("hourRules");

  // ---------- Utilidades horas (bloques de 1 hora)
  function hourIntFromHHMM(hhmm){
    const m = minutesFromHHMM(hhmm);
    if(m===null) return null;
    return Math.floor(m/60);
  }
  function allowedHoursFromCourse(c, iso, opts){
    ensureWeekdayState(c);
    const options = opts || {};

    // Para compatibilidad con llamadas antiguas, si no se da ISO asumimos el horario principal
    const ex = c?.prog?.extra;

    const toHours = (hStart, hEnd)=>{
      const m1 = minutesFromHHMM(hStart);
      const m2 = minutesFromHHMM(hEnd);
      if(m1===null || m2===null || m2<=m1) return [];
      const hs = Math.floor(m1/60);
      const he = Math.floor(m2/60);
      const out = [];
      for(let h=hs; h<he; h++) out.push(h);
      return out;
    };

    let wd = null;
    if(iso){
      const dt = parseISODate(iso);
      if(dt){
        const d = dt.getDay(); // 0 DO .. 6 SA
        wd = (d===0 ? 0 : d);
      }
    }

    const outSet = new Set();

    // Horario 1
    if(!iso || selectedDowSet1(c).has(wd)){
      for(const h of toHours(c.prog.hStart, c.prog.hEnd)) outSet.add(h);
    }

    // Horario 2 (si procede)
    const useExtra = !!(ex && ex.enabled && !options.ignoreExtra);
    if(useExtra){
      const ov = validateInternalScheduleOverlap(c);
      if(ov.ok){
        if(iso && selectedDowSet2(c).has(wd)){
          for(const h of toHours(ex.hStart, ex.hEnd)) outSet.add(h);
        }
      }
    }

    return Array.from(outSet).sort((a,b)=>a-b);
  }
  function pad2(n){ return String(n).padStart(2,"0"); }

  // Forzar selección SOLO por horas (minutos en 00) en Hora Inicio / Hora Fin
  function _normalizeHourValue(hhmm, mode){
    const v = String(hhmm||"").trim();
    if(!/^\d{2}:\d{2}$/.test(v)) return v;
    let [hh, mm] = v.split(":").map(n=>Number(n));
    if(Number.isNaN(hh) || Number.isNaN(mm)) return v;
    if(mm === 0) return `${pad2(hh)}:00`;

    // mode: "floor" (inicio) o "ceil" (fin)
    if(mode === "ceil"){
      // evitar 24:00 (no soportado por input[type=time]); se mantiene en 23:00
      if(hh >= 23) return "23:00";
      hh = hh + 1;
    }
    return `${pad2(hh)}:00`;
  }

  function normalizeHoraInputs(){
    const vStart = _normalizeHourValue(formEls.horaInicio.value, "floor");
    const vEnd   = _normalizeHourValue(formEls.horaFin.value, "ceil");
    if(vStart && vStart !== formEls.horaInicio.value) formEls.horaInicio.value = vStart;
    if(vEnd && vEnd !== formEls.horaFin.value) formEls.horaFin.value = vEnd;

    // Horario 2 (si existe)
    if(formEls.horaInicio2 && formEls.horaFin2){
      const vStart2 = _normalizeHourValue(formEls.horaInicio2.value, "floor");
      const vEnd2   = _normalizeHourValue(formEls.horaFin2.value, "ceil");
      if(vStart2 && vStart2 !== formEls.horaInicio2.value) formEls.horaInicio2.value = vStart2;
      if(vEnd2 && vEnd2 !== formEls.horaFin2.value) formEls.horaFin2.value = vEnd2;
    }
  }

  // Ajuste 2: bloquear/filtrar Hora Fin según Hora Inicio (incluye regla especial 00:00)
  const _END_TIME_VALUES = Array.from({length:24}, (_,h)=> `${String(h).padStart(2,"0")}:00`);
  function rebuildHoraFinOptions(startSel, endSel){
    if(!startSel || !endSel) return;
    const startVal = (startSel.value||"").trim();
    const startH = hourIntFromHHMM(startVal); // 0..23 o null
    const prev = (endSel.value||"").trim();

    let allowed = [];
    if(startH === null){
      allowed = _END_TIME_VALUES.slice();
    }else{
      for(let h=startH+1; h<=23; h++) allowed.push(`${pad2(h)}:00`);
      // 00:00 se habilita solo si Hora Inicio >= 12:00 (representa 24:00)
      if(startH >= 12) allowed.push("00:00");
    }

    endSel.innerHTML = `<option value="">Seleccione…</option>` + allowed.map(v=> `<option value="${v}">${v}</option>`).join("");

    if(prev && allowed.includes(prev)) endSel.value = prev;
    else if(allowed.length) endSel.value = allowed[0];
    else endSel.value = "";
  }

  function enforceHoraFinRules(){
    rebuildHoraFinOptions(formEls.horaInicio, formEls.horaFin);
    if(formEls.horaInicio2 && formEls.horaFin2) rebuildHoraFinOptions(formEls.horaInicio2, formEls.horaFin2);
  }


  function hourBlockLabel(h){
    // h: 0..23 => "06:00 - 07:00"
    const h2 = (h + 1) % 24;
    return `${pad2(h)}:00 - ${pad2(h2)}:00`;
  }

  function ensureCourseSchedule(c){
    if(!c.days){
      c.days = {
        excluded: new Set(),      // Días quitados manualmente por el usuario
        blocked: new Set(),       // Días completamente ocupados (derivado de fichas anteriores en el horario actual)
        selected: [],
        byDate: new Map(),
        activeISO: null,
        autoHours: true,
        partialNotified: new Set() // para evitar repetir avisos por disponibilidad parcial
      };
    }
    if(!c.days.byDate) c.days.byDate = new Map();
    if(!c.days.excluded) c.days.excluded = new Set();
    if(!c.days.blocked) c.days.blocked = new Set();
    if(!c.days.selected) c.days.selected = [];
    if(typeof c.days.activeISO === "undefined") c.days.activeISO = null;
    if(!c.days.partialNotified) c.days.partialNotified = new Set();
  
    if(typeof c.days.autoHours === "undefined") c.days.autoHours = true;
}



  // ---------- Ocupación por hora: Map(iso -> Map(hour -> {cursoIndex,label}))
  // Reemplaza/asegura estructura
  STATE.occupancy = STATE.occupancy || new Map();

  function getOccMapForDay(iso){
    if(!STATE.occupancy.has(iso)) STATE.occupancy.set(iso, new Map());
    return STATE.occupancy.get(iso);
  }

  function isHourBusy(iso, hour, ignoreCourseIdx){
    const m = STATE.occupancy.get(iso);
    if(!m) return null;
    const e = m.get(hour);
    if(!e) return null;
    if(typeof ignoreCourseIdx === "number" && e.cursoIndex === ignoreCourseIdx) return null;
    return e;
  }
  function isHourBusyPrior(iso, hour, courseIdx){
    const e = isHourBusy(iso, hour, courseIdx);
    if(!e) return null;
    // Regla: para el curso actual, bloquea solo si proviene de una ficha anterior (o externa).
    if(typeof courseIdx === "number" && typeof e.cursoIndex === "number" && e.cursoIndex > courseIdx) return null;
    return e;
  }

  function occupiedHoursPrior(iso, courseIdx){
    const m = STATE.occupancy.get(iso);
    if(!m) return [];
    const out = [];
    for(const [h,e] of m.entries()){
      if(typeof courseIdx === "number" && typeof e?.cursoIndex === "number"){
        if(e.cursoIndex < courseIdx) out.push(h);
      }else if(typeof courseIdx === "number"){
        // Ocupación externa: aplica a todos
        out.push(h);
      }else{
        out.push(h);
      }
    }
    out.sort((a,b)=>a-b);
    return out;
  }


  function releaseOccupancyForCourse(courseIdx){
    for(const [iso, m] of STATE.occupancy.entries()){
      for(const [h, e] of m.entries()){
        if(e.cursoIndex === courseIdx) m.delete(h);
      }
      if(m.size === 0) STATE.occupancy.delete(iso);
    }
  }

  function courseLabel(c){
    const n = (c.program.name || `Curso ${c.idx+1}`).trim();
    return `Curso ${c.idx+1} – ${n}`;
  }

  function assignOccupancyForCourse(c){
    ensureCourseSchedule(c);
    const label = courseLabel(c);

    for(const [iso, setHours] of c.days.byDate.entries()){
      const m = getOccMapForDay(iso);
      for(const h of setHours){
        m.set(h, { cursoIndex:c.idx, label, ficha: String(c?.meta?.ficha||"").trim() });
      }
    }
  }

  function findConflictsAgainstOccupancy(c){
    ensureCourseSchedule(c);
    const out = [];
    for(const [iso, setHours] of c.days.byDate.entries()){
      for(const h of setHours){
        const e = isHourBusyPrior(iso, h, c.idx);
        if(e){
          out.push(`${iso} ${pad2(h)}:00 (${courseLabel(c)}) ocupa una hora ya asignada a ${e.label}`);
        }
      }
    }
    return out;
  }

  // ---------- Cálculo horas (ahora por bloques seleccionados)
  function computeSelectionAndHours(c){
    ensureCourseSchedule(c);
    // Limpiar por rango/días excluidos (defensivo)
    const { baseSelectable } = computeBaseSelectableDays(c);
    const baseSet = new Set(baseSelectable);

    for(const iso of Array.from(c.days.byDate.keys())){
      if(!baseSet.has(iso) || c.days.excluded.has(iso)){
        c.days.byDate.delete(iso);
      }
    }

    const selected = Array.from(c.days.byDate.keys()).sort();
    c.days.selected = selected;

    let total = 0;
    for(const iso of selected){
      total += (c.days.byDate.get(iso)?.size || 0);
    }

    c.computed.hoursPerDay = 0; // variable
    c.computed.totalHours = total;
    return { selected, hoursPerDay: 0, totalHours: total };
  }

  

  function suggestEndDateForTargetHours(c, targetHours){
    try{ ensureCourseSchedule(c); }catch(e){}
    const selected = Array.from((c?.days?.byDate || new Map()).keys()).sort();
    let acc = 0;
    for(const iso of selected){
      acc += (c.days.byDate.get(iso)?.size || 0);
      if(acc >= targetHours) return iso;
    }
    return selected.length ? selected[selected.length-1] : null;
  }
// ---------- Recalcular (cuando cambian fechas/horas o al cerrar calendario)
  function recalcSelectionAndHours(fromCalendar){
    const c = getActive();
    if(!c) return;

    // actualizar del UI (Horario 1)
    c.prog.start = formEls.fechaInicio.value;
    c.prog.end = formEls.fechaFin.value;
    c.prog.hStart = formEls.horaInicio.value;
    c.prog.hEnd = formEls.horaFin.value;

    ensureWeekdayState(c);
    try{ applyWeekdaysFromUI(c); }catch(e){}

    ensureCourseSchedule(c);

    const ov = validateInternalScheduleOverlap(c);
    const ignoreExtra = (!ov.ok);

    const { baseSelectable } = computeBaseSelectableDays(c);
    const baseSet = new Set(baseSelectable);

    // conservar excluidos que sigan en rango
    c.days.excluded = new Set(Array.from(c.days.excluded).filter(iso => baseSet.has(iso)));

    // recomputar días completamente ocupados (derivado)
    c.days.blocked = new Set();

    // Quitar entradas fuera de rango/excluidas
    for(const iso of Array.from(c.days.byDate.keys())){
      if(!baseSet.has(iso) || c.days.excluded.has(iso)) c.days.byDate.delete(iso);
    }

    // Crear/ajustar entradas por defecto para días seleccionados (no excluidos)
    for(const iso of baseSelectable){
      if(c.days.excluded.has(iso)) continue;

      const allowedIso = allowedHoursFromCourse(c, iso, { ignoreExtra });
      if(!allowedIso || !allowedIso.length){
        // en este día no hay horario aplicable
        c.days.byDate.delete(iso);
        continue;
      }

      if(!c.days.byDate.has(iso)){
        const set = new Set();
        for(const h of allowedIso){
          if(!isHourBusyPrior(iso, h, c.idx)) set.add(h);
        }
        if(set.size){
          c.days.byDate.set(iso, set);
        }else{
          // sin horas disponibles -> bloqueado por ficha(s) anterior(es)
          c.days.blocked.add(iso);
        }
      }else{
        // Si el usuario no ha personalizado horas en el calendario, mantener sincronizado con Hora Inicio/Fin.
        if(c.days.autoHours){
          const set = new Set();
          for(const h of allowedIso){
            if(!isHourBusyPrior(iso, h, c.idx)) set.add(h);
          }
          if(set.size){
            c.days.byDate.set(iso, set);
          }else{
            c.days.byDate.delete(iso);
            c.days.blocked.add(iso);
          }
        }else{
          // recortar a horas permitidas, y quitar ocupadas
          const set = c.days.byDate.get(iso);
          for(const h of Array.from(set)){
            if(!allowedIso.includes(h) || isHourBusy(iso, h, c.idx)) set.delete(h);
          }
          if(set.size===0){
            c.days.byDate.delete(iso);
            c.days.blocked.add(iso);
          }
        }
      }
    }

    // set activeISO
    const keys = Array.from(c.days.byDate.keys()).sort();
    if(!c.days.activeISO || !c.days.byDate.has(c.days.activeISO)){
      c.days.activeISO = keys.length ? keys[0] : null;
    }

    computeSelectionAndHours(c);
    renderDaysList();

    // Aviso: cuando existan cruces parciales, se programa solo en las horas disponibles (naranja)
    try{
      if(!fromCalendar){
        let n = 0;
        for(const iso of c.days.byDate.keys()){
          const st = dayStatusForCourse(c, iso);
          if(st.partialBusy && !c.days.partialNotified.has(iso)){
            c.days.partialNotified.add(iso);
            n++;
          }
        }
        if(n>0){
          toast(`Se ajustó la programación: ${n} día(s) tenían cruces y se programaron solo en las horas disponibles (marcadas en naranja).`);
        }
      }
    }catch(e){}

    // Mostrar error de solape interno (si aplica) sin romper UI
    if(!ov.ok && formEls.calcHint){
      formEls.calcHint.textContent = ov.msg;
      try{ formEls.calcHint.style.color = "#b91c1c"; }catch(e){}
    }else if(formEls.calcHint){
      try{ formEls.calcHint.style.color = ""; }catch(e){}
    }
  }

  // ---------- Render tabla de días (en pantalla principal)
  function renderDaysList(){
    const c = getActive();
    if(!c) return;

    const pr = validatePrereqsForDayList();
    ensureWeekdayState(c);
    const canShow = pr.ok && c.days && c.days.byDate && c.days.byDate.size > 0 && !!c.prog.calculated;

    if(!canShow){
      formEls.daysListWrap.style.display = "none";
      return;
    }

    formEls.daysListWrap.style.display = "block";
    formEls.daysTbody.innerHTML = "";

    const { selected, totalHours } = computeSelectionAndHours(c);

    // badge horas vs programa
    const progHours = Number(c.program.hours || 0);
    formEls.hoursBadge.textContent = `${totalHours} / ${progHours} horas`;

    

    if(formEls.approxDateBadge){
      formEls.approxDateBadge.style.display = "none";
      formEls.approxDateBadge.dataset.iso = "";
      formEls.approxDateBadge.textContent = "";
    }
let rules = [];
    let badgeCls = "badge";

    if(!progHours){
      badgeCls = "badge warn";
      rules.push(`<span class="badge warn">Defina un programa válido para validar horas</span>`);
    }else if(totalHours === progHours){
      badgeCls = "badge ok";
      rules.push(`<span class="badge ok">Horas OK</span>`);
    }else if(totalHours > progHours){
      badgeCls = "badge danger";
      rules.push(`<span class="badge danger">Excede horas del programa</span>`);
      const sugISO = suggestEndDateForTargetHours(c, progHours);
      if(formEls.approxDateBadge){
        if(sugISO && formEls.fechaFin.value !== sugISO){
          formEls.approxDateBadge.textContent = `Fecha fin aprox.: ${fmtDMYYYY(sugISO)}`;
          formEls.approxDateBadge.style.display = "inline-flex";
          formEls.approxDateBadge.dataset.iso = sugISO;
        }else{
          formEls.approxDateBadge.style.display = "none";
          formEls.approxDateBadge.dataset.iso = "";
          formEls.approxDateBadge.textContent = "";
        }
      }

    }else{
      badgeCls = "badge warn";
      rules.push(`<span class="badge warn">Faltan horas por programar</span>`);
    }

    formEls.hoursBadge.className = badgeCls;
    if(formEls.hoursRulesHint) formEls.hoursRulesHint.innerHTML = rules.join(" ");
    // lista
    selected.forEach(iso=>{
      const dateObj = parseISODate(iso);
      const dn = dateObj ? dayNameES(dateObj) : "";
      const set = c.days.byDate.get(iso) || new Set();
      const cnt = set.size;

      // resumen: min y max+1 si hay continuidad; si no, mostrar "var."
      let summary = "—";
      if(cnt){
        const hours = Array.from(set).sort((a,b)=>a-b);
        const minH = hours[0], maxH = hours[hours.length-1];
        const isContig = hours.every((h,idx)=> idx===0 || h === hours[idx-1]+1);
        summary = isContig ? `${pad2(minH)}:00 a ${pad2(maxH+1)}:00` : `Horario variable (${cnt} bloques)`;
      }

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${dn}</td>
        <td>${fmtDMYYYY(iso)}</td>
        <td>${summary}</td>
        <td><strong>${cnt}</strong></td>
        <td class="inline" style="gap:8px;">
          <button class="btn outline" type="button" data-edit="${iso}">Editar</button>
          <button class="btn danger" type="button" data-remove="${iso}">Quitar día</button>
        </td>
      `;
      formEls.daysTbody.appendChild(tr);
    });

    // acciones tabla
    formEls.daysTbody.querySelectorAll("button[data-remove]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const iso = btn.getAttribute("data-remove");
        if(!iso) return;
        ensureCourseSchedule(c);
        c.days.excluded.add(iso);
        c.days.byDate.delete(iso);
        if(c.days.activeISO === iso){
          const k = Array.from(c.days.byDate.keys()).sort();
          c.days.activeISO = k.length ? k[0] : null;
        }
        recalcSelectionAndHours(true);
        toast("Día quitado.");
      });
    });

    formEls.daysTbody.querySelectorAll("button[data-edit]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const iso = btn.getAttribute("data-edit");
        if(!iso) return;
        ensureCourseSchedule(c);
        c.days.activeISO = iso;
        openCalendarModal();
      });
    });

    formEls.hoursRulesHint.innerHTML = rules.join(" ");
  }

  // ---------- Validaciones para abrir calendario
  function validatePrereqsForCalendar(c){

    normalizeHoraInputs();
    ensureWeekdayState(c);

    // Días
    if(selectedDowSet(c).size === 0) return { ok:false, msg:"Seleccione al menos un día (LU–SA) para programar." };

    // Programa
    if(!c.program.code || !c.program.name || !c.program.hours) return { ok:false, msg:"Ingrese un Código de Programa válido (debe existir en el catálogo)." };

    // Fechas
    const s = parseISODate(formEls.fechaInicio.value);
    const e = parseISODate(formEls.fechaFin.value);
    if(!s || !e) return { ok:false, msg:"Defina Fecha Inicio y Fecha Finalización." };
    const minISO = formEls.fechaInicio.getAttribute("min") || todayISO();
    if(formEls.fechaInicio.value && formEls.fechaInicio.value < minISO) return { ok:false, msg:"Fecha Inicio no puede ser anterior a hoy." };
    if(e < s) return { ok:false, msg:"Rango inválido: Fecha Finalización debe ser mayor o igual a Fecha Inicio." };

    // Horario 1
    const m1 = minutesFromHHMM(formEls.horaInicio.value);
    const m2 = minutesFromHHMM(formEls.horaFin.value);
    if(m1 === null || m2 === null || m2 <= m1) return { ok:false, msg:"Defina Hora Inicio y Hora Fin válidas." };
    if((m1 % 60) !== 0 || (m2 % 60) !== 0) return { ok:false, msg:"Para cumplir la regla, use minutos en 00 (bloques de 1 hora)." };

    // Horario 2 (si está activo)
    if(c.prog.extra && c.prog.extra.enabled){
      if(selectedDowSet2(c).size === 0) return { ok:false, msg:"Seleccione al menos un día en el Horario Complementario (Días 2)." };

      const m3 = minutesFromHHMM(formEls.horaInicio2 ? formEls.horaInicio2.value : "");
      const m4 = minutesFromHHMM(formEls.horaFin2 ? formEls.horaFin2.value : "");
      if(m3 === null || m4 === null || m4 <= m3) return { ok:false, msg:"Defina Hora Inicio 2 y Hora Fin 2 válidas." };
      if((m3 % 60) !== 0 || (m4 % 60) !== 0) return { ok:false, msg:"Para cumplir la regla, use minutos en 00 (bloques de 1 hora) en Horario 2." };

      const ov = validateInternalScheduleOverlap(c);
      if(!ov.ok) return { ok:false, msg: ov.msg };
    }

    return { ok:true, msg:"OK" };
  }

  // ---------- Calendario: abrir / render / editor de horas
  function openCalendarModal(){
    const c = getActive();
    const v = validatePrereqsForCalendar(c);
    if(!v.ok){
      toast(v.msg);
      formEls.diasHint.textContent = v.msg;
      formEls.diasHint.style.color = "var(--danger)";
      return;
    }

    // sincronizar valores base
    c.prog.start = formEls.fechaInicio.value;
    c.prog.end = formEls.fechaFin.value;
    c.prog.hStart = formEls.horaInicio.value;
    c.prog.hEnd = formEls.horaFin.value;

    ensureCourseSchedule(c);
    recalcSelectionAndHours(false);

    $("calTitle").textContent = `Seleccionar programación • Curso ${c.idx+1}`;
    calendarModal.classList.add("show");
    renderCalendar();
  }

  function setActiveDay(c, iso){
    ensureCourseSchedule(c);
    if(!iso) return;
    if(c.days.excluded.has(iso) || c.days.blocked.has(iso)) return;
    if(!c.days.byDate.has(iso)) return;
    c.days.activeISO = iso;
  }

  function dayStatusForCourse(c, iso){
    const allowed = allowedHoursFromCourse(c, iso);
    const allowedLen = allowed.length || 0;

    let busyCount = 0;
    for(const h of allowed){
      if(isHourBusyPrior(iso, h, c.idx)) busyCount++;
    }

    const fullBusy = allowedLen > 0 && busyCount === allowedLen;
    const partialBusy = busyCount > 0 && busyCount < allowedLen;

    // 'blocked' se reserva para días completamente ocupados en el rango/horario actual.
    return { busyCount, fullBusy, partialBusy, allowedLen, blocked: fullBusy };
  }

function renderHourPanel(c){
    ensureCourseSchedule(c);
    const iso = c.days.activeISO;
    const allowed = allowedHoursFromCourse(c, iso);

    if(!iso || !c.days.byDate.has(iso)){
      activeDayLabel.textContent = "—";
      hourPanelHint.style.display = "block";
      hourList.style.display = "none";
      dayHoursBadge.textContent = "0 horas/día";
      hourRules.textContent = "";
      return;
    }

    const dateObj = parseISODate(iso);
    activeDayLabel.textContent = dateObj ? `${dayNameES(dateObj)} • ${fmtDMYYYY(iso)}` : iso;

    hourPanelHint.style.display = "none";
    hourList.style.display = "grid";
    hourList.innerHTML = "";

    const set = c.days.byDate.get(iso) || new Set();

    for(const h of allowed){
      const occ = isHourBusyPrior(iso, h, c.idx);
      const row = document.createElement("div");
      row.className = "hour-item" + (occ ? " busy disabled" : "");
      row.title = occ ? `Ocupado por: ${occ.label}` : "Disponible";

      const checked = set.has(h);
      if(checked) row.classList.add("on");
      row.innerHTML = `
        <label class="chk" style="gap:10px; cursor:pointer;">
          <input type="checkbox" data-hour="${h}" ${checked ? "checked":""} ${occ ? "disabled":""} />
          <span class="hlabel">${hourBlockLabel(h)}</span>
        </label>
        <span class="hsmall">${occ ? "Ocupado" : "Disponible"}</span>
      `;
      hourList.appendChild(row);
      // Click en el bloque completo (más área): alterna selección si está disponible.
      // Si está ocupado, solo muestra el detalle del cruce.
      row.addEventListener("click", (ev)=>{
        if(occ){
          const msg = conflictMessageForHour(c, iso, h);
          showInfo("Día no disponible en ese horario", msg);
          return;
        }
        // Si se hace clic en el checkbox o en el label, el navegador ya alterna el input.
        if(ev.target && (ev.target.tagName === "INPUT" || ev.target.closest("label.chk"))) return;

        const input = row.querySelector('input[type="checkbox"][data-hour]');
        if(!input || input.disabled) return;
        input.checked = !input.checked;
        input.dispatchEvent(new Event("change", { bubbles:true }));
      });
    }

    // listeners horas
    hourList.querySelectorAll('input[type="checkbox"][data-hour]').forEach(chk=>{
      chk.addEventListener("change", ()=>{
        c.days.autoHours = false;
        const h = Number(chk.getAttribute("data-hour"));
        const currentSet = new Set(Array.from(set));
        if(chk.checked) currentSet.add(h); else currentSet.delete(h);
        const r = chk.closest(".hour-item"); if(r) r.classList.toggle("on", chk.checked);

        if(applyHoursToAll.checked){
          applyHourSetToAllDays(c, currentSet);
        }else{
          set.clear();
          for(const x of currentSet) set.add(x);
          // si queda vacío, excluir día
          if(set.size===0){
            c.days.byDate.delete(iso);
            c.days.excluded.add(iso);
            const k = Array.from(c.days.byDate.keys()).sort();
            c.days.activeISO = k.length ? k[0] : null;
          }
        }

        computeSelectionAndHours(c);
        syncFechaFinToLastSelected(c);
        updateCalendarBadges(c);
        renderCalendar();
      });
    });

    dayHoursBadge.textContent = `${set.size} horas/día`;

    // regla rápida
    const total = Number(c.computed.totalHours || 0);
    const ph = Number(c.program.hours || 0);
    if(!ph){
      hourRules.innerHTML = `Defina un programa válido para validar horas.`;
    }else if(total === ph){
      hourRules.innerHTML = `<span class="badge ok">Total ${total} horas • OK</span>`;
    }else if(total > ph){
      hourRules.innerHTML = `<span class="badge danger">Total ${total} horas • Excede ${ph}</span>`;
    }else{
      hourRules.innerHTML = `<span class="badge warn">Total ${total} horas • Faltan ${ph-total}</span>`;
    }
  }

  function applyHourSetToAllDays(c, hourSet){
    ensureCourseSchedule(c);
    c.days.autoHours = false;
    const removedDays = [];
    for(const iso of Array.from(c.days.byDate.keys())){
      const set = new Set();
      for(const h of hourSet){
        if(!isHourBusyPrior(iso, h, c.idx)) set.add(h);
      }
      if(set.size){
        c.days.byDate.set(iso, set);
      }else{
        c.days.byDate.delete(iso);
        c.days.excluded.add(iso);
        removedDays.push(iso);
      }
    }
    if(removedDays.length){
      toast(`Algunos días quedaron sin horas disponibles y se retiraron (${removedDays.length}).`);
    }
    // actualizar activeISO si fue retirado
    if(c.days.activeISO && !c.days.byDate.has(c.days.activeISO)){
      const k = Array.from(c.days.byDate.keys()).sort();
      c.days.activeISO = k.length ? k[0] : null;
      // Ajustar Fecha Finalización al último día en verde si se retiraron días
    syncFechaFinToLastSelected(c);
  }
    // Ajustar Fecha Finalización al último día en verde si se retiraron días
    syncFechaFinToLastSelected(c);
  }

  function updateCalendarBadges(c){
    const { selected, totalHours } = computeSelectionAndHours(c);
    $("calHoursPreview").textContent = `${totalHours} horas`;
    // busy badge: si existe al menos una hora ocupada en el rango en algún día seleccionable
    const { baseSelectable } = computeBaseSelectableDays(c);
    let anyBusy = false;
    for(const iso of baseSelectable){
      const st = dayStatusForCourse(c, iso);
      if(st.partialBusy || st.fullBusy){
        anyBusy = true; break;
      }
    }
    $("calBusyBadge").style.display = anyBusy ? "inline-flex" : "none";
  }

  function renderCalendar(){
    const c = getActive();
    if(!c) return;

    ensureCourseSchedule(c);
    const allowedDows = selectedDowSet(c);

    const s = (c.prog.start || formEls.fechaInicio.value || "");
    const e = (c.prog.end || formEls.fechaFin.value || "");

    $("calRangeBadge").textContent = (s && e) ? `${fmtDMYYYY(s)} → ${fmtDMYYYY(e)}` : "—";

    const wrap = $("miniWrap");
    if(!wrap) return;
    wrap.innerHTML = "";

    const start = parseISODate(s);
    const end = parseISODate(e);
    if(!start || !end || start > end){
      updateCalendarBadges(c);
      renderHourPanel(c);
      return;
    }
    start.setHours(0,0,0,0);
    end.setHours(0,0,0,0);

    // Inicializar byDate si está vacío (rango recién definido)
    const { baseSelectable } = computeBaseSelectableDays(c);
    if((!c.days.byDate || c.days.byDate.size === 0) && baseSelectable.length){
      c.days.blocked = new Set();
      for(const iso of baseSelectable){
        if(c.days.excluded.has(iso)) continue;
        const allowedIso = allowedHoursFromCourse(c, iso);
        if(!allowedIso || !allowedIso.length) continue;

        const set = new Set();
        for(const h of allowedIso){
          if(!isHourBusyPrior(iso, h, c.idx)) set.add(h);
        }
        if(set.size){
          c.days.byDate.set(iso, set);
        }else{
          c.days.blocked.add(iso);
        }
      }
      const k = Array.from(c.days.byDate.keys()).sort();
      c.days.activeISO = k.length ? k[0] : null;
    }

    const selectedSet = new Set(Array.from(c.days.byDate.keys()));

    // Render mini calendars por mes
    const monthCursor = new Date(start.getFullYear(), start.getMonth(), 1);
    const monthEnd = new Date(end.getFullYear(), end.getMonth(), 1);

    while(monthCursor <= monthEnd){
      const y = monthCursor.getFullYear();
      const m = monthCursor.getMonth();

      const card = document.createElement("div");
      card.className = "mini-month";

      const title = document.createElement("div");
      title.className = "mini-month-title";
      title.textContent = String(MONTH_NAMES[m]).toUpperCase();
      card.appendChild(title);

      const grid = document.createElement("div");
      grid.className = "mini-grid";

      // Días semana
      for(const dw of DOWS){
        const h = document.createElement("div");
        h.className = "mini-dow";
        h.textContent = dw;
        grid.appendChild(h);
      }

      const first = new Date(y, m, 1);
      const lead = first.getDay(); // 0=DO
      for(let i=0;i<lead;i++){
        const el = document.createElement("div");
        el.className = "mini-day empty";
        el.textContent = "0";
        grid.appendChild(el);
      }

      const daysInMonth = new Date(y, m+1, 0).getDate();
      for(let d=1; d<=daysInMonth; d++){
        const date = new Date(y, m, d);
        date.setHours(0,0,0,0);
        const iso = formatISO(y, m+1, d);

        const el = document.createElement("div");
        el.className = "mini-day";
        el.textContent = String(d);

        const inRange = (date >= start && date <= end);
        if(!inRange){
          el.classList.add("out");
          grid.appendChild(el);
          continue;
        }

        const dow = date.getDay();
        const isHoliday = (y === 2026) && FESTIVOS_2026.has(iso);
        const nonWork = (dow === 0) || isHoliday;

        if(nonWork){
          el.classList.add("nonwork");
          el.title = (dow===0) ? "Domingo (no programable)" : "Festivo (no programable)";
          grid.appendChild(el);
          continue;
        }

        // Fuera de los días seleccionados (LU–SA)
        if(!allowedDows.has(dow)){
          el.classList.add("out");
          el.title = "Día no seleccionado para programación (LU–SA).";
          grid.appendChild(el);
          continue;
        }

        const st = dayStatusForCourse(c, iso);
        const blocked = st.fullBusy;

        const selected = selectedSet.has(iso);
        const removed = c.days.excluded.has(iso) && !selected;

        // Estilos por estado
        if(blocked){
          el.classList.add("excluded","fullbusy");
        } else if(selected && st.partialBusy){
          // Disponibilidad parcial: el sistema guarda solo las horas libres (marcado en naranja)
          el.classList.add("partialbusy");
        }

        if(selected) el.classList.add("selected");
        else if(removed && !blocked) el.classList.add("removed");

        if(c.days.activeISO === iso) el.classList.add("active-day");

        // conexión visual (solo seleccionados)
        if(selected){
          const prev = new Date(y, m, d-1); prev.setHours(0,0,0,0);
          const next = new Date(y, m, d+1); next.setHours(0,0,0,0);
          const prevISO = formatISO(prev.getFullYear(), prev.getMonth()+1, prev.getDate());
          const nextISO = formatISO(next.getFullYear(), next.getMonth()+1, next.getDate());
          if(!selectedSet.has(prevISO)) el.classList.add("sel-left");
          if(!selectedSet.has(nextISO)) el.classList.add("sel-right");
        }

        // Interacción: 1er click activa, 2do click excluye (si ya está activo). Si está excluido, click restaura.
        if(!st.fullBusy){
          el.style.cursor = "pointer";
          el.addEventListener("click", ()=>{
            ensureCourseSchedule(c);

            const isSel = c.days.byDate.has(iso);

            if(isSel){
              // 1er clic: activar (para editar horas). 2do clic: excluir.
              if(c.days.activeISO !== iso){
                c.days.activeISO = iso;
                // Si tiene cruces parciales, informar una sola vez al usuario
                try{
                  const st2 = dayStatusForCourse(c, iso);
                  if(st2.partialBusy && !c.days.partialNotified.has(iso)){
                    c.days.partialNotified.add(iso);
                    showInfo("Día con disponibilidad parcial", partialAvailabilityMessage(c, iso));
                  }
                }catch(e){}
              }else{
                c.days.byDate.delete(iso);
                c.days.excluded.add(iso);
              }
            }else{
              // incluir/restaurar
              c.days.excluded.delete(iso);
              const allowed = allowedHoursFromCourse(c, iso);
              const set = new Set();
              for(const h of allowed){
                if(!isHourBusyPrior(iso, h, c.idx)) set.add(h);
              }
              if(set.size){
                c.days.byDate.set(iso, set);
                c.days.activeISO = iso;
                // Si el día queda con horas libres parciales, mostrar detalle del cruce
                try{
                  const st2 = dayStatusForCourse(c, iso);
                  if(st2.partialBusy && !c.days.partialNotified.has(iso)){
                    c.days.partialNotified.add(iso);
                    showInfo("Día con disponibilidad parcial", partialAvailabilityMessage(c, iso));
                  }
                }catch(e){}
              }else{
                c.days.excluded.add(iso);
              }
            }

            const k = Array.from(c.days.byDate.keys()).sort();
            if(!c.days.activeISO || !c.days.byDate.has(c.days.activeISO)){
              c.days.activeISO = k.length ? k[0] : null;
            }

            computeSelectionAndHours(c);
            invalidateCalc(c);
            // Si se quitó el último día, ajustar Fecha Finalización al último día en verde
            syncFechaFinToLastSelected(c);
            renderHourPanel(c);
            renderDaysList();
            renderCalendar();
          });
          if(selected){
            el.title = (c.days.activeISO === iso)
              ? "Clic para excluir este día"
              : "Clic para activar (editar horas)";
          }else if(removed){
            el.title = "Clic para restaurar este día";
          }else{
            el.title = "Clic para incluir este día";
          }
        }else{
          el.title = "Día no disponible en ese horario";
          el.style.cursor = "pointer";
          el.addEventListener("click", ()=>{
            ensureCourseSchedule(c);
            const msg = conflictMessageForDayInAllowedRange(c, iso);
            showInfo("Día no disponible en ese horario", msg);
          });
        }

        grid.appendChild(el);
      }

      // completar fila final
      while((grid.children.length - 7) % 7 !== 0){
        const el = document.createElement("div");
        el.className = "mini-day empty";
        el.textContent = "0";
        grid.appendChild(el);
      }

      card.appendChild(grid);
      wrap.appendChild(card);

      monthCursor.setMonth(monthCursor.getMonth()+1);
    }

    updateCalendarBadges(c);
    renderHourPanel(c);
  }

  // Botones del panel de horas
  $("btnDayAll").addEventListener("click", ()=>{
    const c = getActive();
    if(!c) return;
    ensureCourseSchedule(c);
    c.days.autoHours = false;
    if(!c.days.activeISO || !c.days.byDate.has(c.days.activeISO)) return;

    const iso = c.days.activeISO;
    const allowed = allowedHoursFromCourse(c, iso);
    const set = new Set();
    for(const h of allowed){
      if(!isHourBusyPrior(iso, h, c.idx)) set.add(h);
    }

    if(applyHoursToAll.checked) applyHourSetToAllDays(c, set);
    else c.days.byDate.set(iso, set);

    computeSelectionAndHours(c);
    invalidateCalc(c);
    renderCalendar();
  });

  $("btnDayNone").addEventListener("click", ()=>{
    const c = getActive();
    if(!c) return;
    ensureCourseSchedule(c);
    c.days.autoHours = false;
    const iso = c.days.activeISO;
    if(!iso) return;

    if(applyHoursToAll.checked){
      // si está aplicar a todos: se retiran todos los días (porque quedarían sin horas)
      for(const k of Array.from(c.days.byDate.keys())){
        c.days.byDate.delete(k);
        c.days.excluded.add(k);
      }
      c.days.activeISO = null;
    }else{
      c.days.byDate.delete(iso);
      c.days.excluded.add(iso);
      const k = Array.from(c.days.byDate.keys()).sort();
      c.days.activeISO = k.length ? k[0] : null;
    }

    computeSelectionAndHours(c);
    invalidateCalc(c);
    syncFechaFinToLastSelected(c);
    renderCalendar();
  });

  // Recalcular cuando cambian fechas/horas (actualización instantánea)
  ["fechaInicio","fechaFin","horaInicio","horaFin"].forEach(id=>{
    const el = $(id);
    if(!el) return;

    // Para fechas: permitir escritura sin recalcular en cada tecla.
    if(id === "fechaInicio" || id === "fechaFin"){
      const handler = ()=>{
        if(isISODateComplete(el.value)) recalcSelectionAndHours(false);
      };
      el.addEventListener("input", handler);
      el.addEventListener("change", handler);
      el.addEventListener("blur", handler);
      return;
    }

    const handler = ()=>{ try{ enforceHoraFinRules(); }catch(e){} recalcSelectionAndHours(false); };
    el.addEventListener("input", handler);
    el.addEventListener("change", handler);
  });

  // Inicializar filtros de Hora Fin
  setTimeout(()=>{ try{ enforceHoraFinRules(); }catch(e){} }, 0);


  // ---------- Programa por nombre: UI y selección
  function selectProgramRecord(rec){
    const c = getActive();
    if(!c) return;

    c.program.code = String(rec.code);
    c.program.name = String(rec.name);
    c.program.hours = Number(rec.hours);

    c.program.aMedida = String(rec.aMedida || "");
    formEls.programCode.value = String(rec.code);
    formEls.programName.value = String(rec.name);
    formEls.programHours.value = Number(rec.hours);

    c.meta.area = (rec.area || "").trim();
    formEls.areaOcupacion.value = c.meta.area;
    formEls.programCodeHint.textContent = "Programa seleccionado.";
    formEls.programCodeHint.style.color = "var(--ok)";
    programNameHint.textContent = "";
    hideProgramSuggestions();

    // Si ya hay calendario seleccionado, recalcular reglas
    recalcSelectionAndHours(false);
    updateObsRestricciones();
  }

  function hideProgramSuggestions(){
    programNameList.style.display = "none";
    programNameList.innerHTML = "";
  }

  function renderProgramSuggestions(items){
    if(!items.length){
      hideProgramSuggestions();
      return;
    }
    programNameList.innerHTML = "";
    for(const rec of items.slice(0, 12)){
      const div = document.createElement("div");
      div.className = "ac-item";
      div.innerHTML = `
        <div class="topline">
          <div class="name">${rec.name}</div>
          <div class="meta">${rec.hours} h</div>
        </div>
        <div class="meta">Código: ${rec.code}</div>
      `;
      div.addEventListener("click", ()=> selectProgramRecord(rec));
      programNameList.appendChild(div);
    }
    programNameList.style.display = "block";
  }

  function openProgramPickModal(name, list){
    programPickHint.textContent = `Se encontraron ${list.length} programas con el nombre: "${name}". Seleccione el correcto (código y horas).`;
    programPickTbody.innerHTML = "";

    list.forEach(rec=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${rec.code}</td>
        <td>${rec.name}</td>
        <td><strong>${rec.hours}</strong></td>
        <td><button class="btn primary" type="button">Usar</button></td>
      `;
      tr.querySelector("button").addEventListener("click", ()=>{
        programPickModal.classList.remove("show");
        selectProgramRecord(rec);
      });
      programPickTbody.appendChild(tr);
    });

    programPickModal.classList.add("show");
  }

  function resolveProgramNameInput(){
    const q = (formEls.programName.value || "").trim();
    const norm = normalizeStr(q);
    if(!q || !STATE.catalogLoaded) return;

    // coincidencia exacta por nombre normalizado
    const list = STATE.catalogNameMap.get(norm);
    if(list && list.length){
      if(list.length === 1){
        selectProgramRecord(list[0]);
      }else{
        openProgramPickModal(q, list);
      }
      return;
    }

    // si no hay exacto, intentar por "startsWith" del display map
    // (busca el primer nombre cuyo norm sea exactamente el escrito)
    // si no hay, dejar como está
  }

  formEls.programName.addEventListener("input", ()=>{
    if(!STATE.catalogLoaded) return;

    if(window.__programNameDebounce) clearTimeout(window.__programNameDebounce);
    window.__programNameDebounce = setTimeout(()=>{
      const q = (formEls.programName.value || "").trim();
      const norm = normalizeStr(q);

      if(norm.length < 2){
        hideProgramSuggestions();
        programNameHint.textContent = "";
        return;
      }

      const p2 = norm.slice(0,2);
      const pool = (STATE.catalogSearchIndex && STATE.catalogSearchIndex.get(p2)) ? STATE.catalogSearchIndex.get(p2) : (STATE.catalogList || []);
      const matches = pool.filter(r => r.nameNorm.includes(norm));

      matches.sort((a,b)=>{
        const aStart = a.nameNorm.startsWith(norm) ? 0 : 1;
        const bStart = b.nameNorm.startsWith(norm) ? 0 : 1;
        if(aStart !== bStart) return aStart - bStart;
        if(a.name.length !== b.name.length) return a.name.length - b.name.length;
        return a.code.localeCompare(b.code);
      });

      renderProgramSuggestions(matches);

      const exact = STATE.catalogNameMap.get(norm);
      if(exact && exact.length > 1){
        programNameHint.textContent = "Hay más de un programa con este nombre. Seleccione el correcto (código y horas).";
        programNameHint.style.color = "var(--warn)";
      }else{
        programNameHint.textContent = "";
      }
    }, 70);
  });

  formEls.programName.addEventListener("keydown", (e)=>{
    if(e.key === "Enter"){
      e.preventDefault();
      resolveProgramNameInput();
    }else if(e.key === "Escape"){
      hideProgramSuggestions();
    }
  });

  formEls.programName.addEventListener("blur", ()=>{
    // resolver exactos al salir del campo
    setTimeout(()=> resolveProgramNameInput(), 120);
  });

  document.addEventListener("click", (e)=>{
    // cerrar sugerencias al hacer clic fuera
    const t = e.target;
    if(!t) return;
    if(t === formEls.programName || programNameList.contains(t)) return;
    hideProgramSuggestions();
  });

  // ---------- Re-implementar lectura de catálogo para construir índice por nombre
  async function handleCatalogFile(file){
    fileStatus.textContent = "Leyendo archivo...";
    try{
      const buf = await file.arrayBuffer();
      const wb = XLSX.read(buf, { type:"array" });

      const sheetName = wb.SheetNames[0];
      const ws = wb.Sheets[sheetName];
      const rows = XLSX.utils.sheet_to_json(ws, { header:1, defval:"", raw:false });

      if(!rows || rows.length < 2){
        throw new Error("La hoja no contiene datos suficientes.");
      }

      const normH = (v)=> (v ?? "").toString().trim().toLowerCase()
        .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
        .replace(/\s+/g," ")
        .replace(/[^\w\s]/g,"");

      const cleanCode = (v)=>{
        let s = (v ?? "").toString().trim();
        if(!s) return "";
        s = s.replace(/\.0+$/,"");
        s = s.replace(/\s+/g," ").trim();
        return s;
      };

      const findHeaderRow = ()=>{
        const maxScan = Math.min(10, rows.length);
        for(let r=0; r<maxScan; r++){
          const hdrNorm = (rows[r]||[]).map(normH);
          const hasCode = hdrNorm.some(h=> h === "codigo_programa" || (h && h.includes("codigo_programa")));
          const hasName = hdrNorm.some(h=> h === "nombre_programa_formacion" || (h && h.includes("nombre_programa")));
          const hasDur  = hdrNorm.some(h=> h === "duracion_programa" || (h && h.includes("duracion_programa")));
          if(hasCode && hasName && hasDur) return r;
        }
        return 0;
      };

      const headerRow = findHeaderRow();
      const header = (rows[headerRow]||[]).map(v => String(v).trim());
      const headerNorm = header.map(normH);

      const findIdx = (cands)=>{
        for(const c of cands){
          const t = normH(c);
          const i = headerNorm.indexOf(t);
          if(i>=0) return i;
        }
        for(let i=0;i<headerNorm.length;i++){
          const h = headerNorm[i];
          for(const c of cands){
            const t = normH(c);
            if(t && h && h.includes(t)) return i;
          }
        }
        return -1;
      };

      const idxCode  = findIdx(["CODIGO_PROGRAMA","CODIGO PROGRAMA"]);
      const idxName  = findIdx(["NOMBRE_PROGRAMA_FORMACION","NOMBRE PROGRAMA FORMACION","NOMBRE_PROGRAMA"]);
      const idxHours = findIdx(["DURACION_PROGRAMA","DURACION PROGRAMA","DURACION HORAS","DURACION_PROGRAMA_HORAS"]);

      let idxArea = findIdx(["AREA_OCUPACION","AREA OCUPACION","AREA"]);
      if(idxArea < 0) idxArea = 5;

      let idxMedida = findIdx(["A LA MEDIDA","A_LA_MEDIDA","A LA MEDIDA?"]);
      if(idxMedida < 0) idxMedida = 6;

      if(idxCode < 0 || idxName < 0 || idxHours < 0){
        throw new Error("No se encontraron las columnas esperadas: CODIGO_PROGRAMA, NOMBRE_PROGRAMA_FORMACION, DURACION_PROGRAMA.");
      }

      const map = new Map();
      const list = [];
      const nameMap = new Map();
      const nameDisp = new Map();
      const searchIndex = new Map(); // prefix2 -> array rec

      for(let r=headerRow+1; r<rows.length; r++){
        const row = rows[r] || [];
        const code = cleanCode(row[idxCode]);
        const name = String(row[idxName] ?? "").trim();
        const hours = Number(String(row[idxHours] ?? "0").toString().replace(/,/g,"."));
        const area = String(row[idxArea] ?? "").trim();
        const aMedida = String(row[idxMedida] ?? "").trim().toUpperCase();
        if(!code || !name || !Number.isFinite(hours) || hours <= 0) continue;

        map.set(code, { name, hours, area, aMedida });

        const nameNorm = normalizeStr(name);
        const rec = { code, name, hours, area, aMedida, nameNorm };
        list.push(rec);

        if(nameNorm){
          if(!nameMap.has(nameNorm)) nameMap.set(nameNorm, []);
          nameMap.get(nameNorm).push(rec);
          if(!nameDisp.has(nameNorm)) nameDisp.set(nameNorm, name);

          const prefixes = new Set();
          if(nameNorm.length >= 2) prefixes.add(nameNorm.slice(0,2));
          for(const t of nameNorm.split(/\s+/g)){
            if(t.length >= 2) prefixes.add(t.slice(0,2));
          }
          for(const p of prefixes){
            if(!p || p.length < 2) continue;
            if(!searchIndex.has(p)) searchIndex.set(p, []);
            searchIndex.get(p).push(rec);
          }
        }
      }

      STATE.catalogMap = map;
      STATE.catalogLoaded = true;
      STATE.catalogList = list;
      STATE.catalogNameMap = nameMap;
      STATE.catalogNameDisplayMap = nameDisp;
      STATE.catalogSearchIndex = searchIndex;

      fileStatus.textContent = `Catálogo cargado: ${map.size} programas.`;
      toast("Catálogo cargado.");

      fileOverlay.classList.remove("show");
      instructorOverlay.classList.add("show");
      $("instructorStatus").textContent = "";

    }catch(err){
      console.error(err);
      fileStatus.textContent = "Error: " + (err && err.message ? err.message : String(err));
      toast("No se pudo leer el catálogo.");
    }
  }


})();

  // Footer: ocultar mientras haya modales abiertos; visible cuando no haya overlays
  const _btnFooterClose = document.getElementById("btnDevFooterClose");
  const _footerWrap = document.getElementById("devFooterWrap");

  // Si el usuario lo cierra manualmente, no se vuelve a mostrar automáticamente
  let _footerDismissed = false;

  function _anyOverlayOpen(){
    return !!document.querySelector(".overlay.show");
  }
  function _setFooterVisible(v){
    if(!_footerWrap) return;
    _footerWrap.style.display = v ? "flex" : "none";
    document.body.classList.toggle("has-dev-footer", v);
  }
  function _updateFooter(){
    if(_footerDismissed){
      _setFooterVisible(false);
      return;
    }
    _setFooterVisible(!_anyOverlayOpen());
  }

  // Botón de cierre del footer
  if(_btnFooterClose && _footerWrap){
    _btnFooterClose.addEventListener("click", ()=>{
      _footerDismissed = true;
      _setFooterVisible(false);
    });
  }

  // Si se reinicia, permitir que vuelva a mostrarse cuando corresponda
  const _btnReiniciar = document.getElementById("btnReiniciar");
  if(_btnReiniciar){
    _btnReiniciar.addEventListener("click", ()=>{
      _footerDismissed = false;
      _updateFooter();
    });
  }

  // Observar apertura/cierre de overlays para evitar que el footer se vea por encima del modal
  const _overlays = Array.from(document.querySelectorAll(".overlay"));
  if(window.MutationObserver && _overlays.length){
    const _mo = new MutationObserver(()=> _updateFooter());
    _overlays.forEach(ov => _mo.observe(ov, { attributes:true, attributeFilter:["class"] }));
  }

  _updateFooter();
</script>
      <button class="df-btn gear" type="button" id="btnDevFooterGear" aria-label="Configuración">⚙</button>
    </div>
  </div>
</body>
</html>
